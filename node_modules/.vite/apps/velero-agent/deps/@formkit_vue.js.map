{
  "version": 3,
  "sources": ["../../../../@formkit/rules/src/accepted.ts", "../../../../@formkit/rules/src/date_after.ts", "../../../../@formkit/rules/src/date_after_or_equal.ts", "../../../../@formkit/rules/src/date_after_node.ts", "../../../../@formkit/rules/src/alpha.ts", "../../../../@formkit/rules/src/alpha_spaces.ts", "../../../../@formkit/rules/src/alphanumeric.ts", "../../../../@formkit/rules/src/date_before.ts", "../../../../@formkit/rules/src/date_before_node.ts", "../../../../@formkit/rules/src/date_before_or_equal.ts", "../../../../@formkit/rules/src/between.ts", "../../../../@formkit/rules/src/confirm.ts", "../../../../@formkit/rules/src/contains_alpha.ts", "../../../../@formkit/rules/src/contains_alpha_spaces.ts", "../../../../@formkit/rules/src/contains_alphanumeric.ts", "../../../../@formkit/rules/src/contains_lowercase.ts", "../../../../@formkit/rules/src/contains_numeric.ts", "../../../../@formkit/rules/src/contains_symbol.ts", "../../../../@formkit/rules/src/contains_uppercase.ts", "../../../../@formkit/rules/src/date_between.ts", "../../../../@formkit/rules/src/date_format.ts", "../../../../@formkit/rules/src/email.ts", "../../../../@formkit/rules/src/ends_with.ts", "../../../../@formkit/rules/src/is.ts", "../../../../@formkit/rules/src/length.ts", "../../../../@formkit/rules/src/lowercase.ts", "../../../../@formkit/rules/src/matches.ts", "../../../../@formkit/rules/src/max.ts", "../../../../@formkit/rules/src/min.ts", "../../../../@formkit/rules/src/not.ts", "../../../../@formkit/rules/src/number.ts", "../../../../@formkit/rules/src/require_one.ts", "../../../../@formkit/rules/src/required.ts", "../../../../@formkit/rules/src/starts_with.ts", "../../../../@formkit/rules/src/symbol.ts", "../../../../@formkit/rules/src/uppercase.ts", "../../../../@formkit/rules/src/url.ts", "../../../../@formkit/inputs/src/plugin.ts", "../../../../@formkit/inputs/src/props.ts", "../../../../@formkit/inputs/src/features/options.ts", "../../../../@formkit/inputs/src/createSection.ts", "../../../../@formkit/inputs/src/compose.ts", "../../../../@formkit/inputs/src/sections/actions.ts", "../../../../@formkit/inputs/src/sections/box.ts", "../../../../@formkit/inputs/src/sections/boxHelp.ts", "../../../../@formkit/inputs/src/sections/boxInner.ts", "../../../../@formkit/inputs/src/sections/boxLabel.ts", "../../../../@formkit/inputs/src/sections/boxOption.ts", "../../../../@formkit/inputs/src/sections/boxOptions.ts", "../../../../@formkit/inputs/src/sections/boxWrapper.ts", "../../../../@formkit/inputs/src/sections/buttonInput.ts", "../../../../@formkit/inputs/src/sections/buttonLabel.ts", "../../../../@formkit/inputs/src/sections/decorator.ts", "../../../../@formkit/inputs/src/sections/fieldset.ts", "../../../../@formkit/inputs/src/sections/fileInput.ts", "../../../../@formkit/inputs/src/sections/fileItem.ts", "../../../../@formkit/inputs/src/sections/fileList.ts", "../../../../@formkit/inputs/src/sections/fileName.ts", "../../../../@formkit/inputs/src/sections/fileRemove.ts", "../../../../@formkit/inputs/src/sections/formInput.ts", "../../../../@formkit/inputs/src/sections/fragment.ts", "../../../../@formkit/inputs/src/sections/help.ts", "../../../../@formkit/inputs/src/sections/icon.ts", "../../../../@formkit/inputs/src/sections/inner.ts", "../../../../@formkit/inputs/src/sections/label.ts", "../../../../@formkit/inputs/src/sections/legend.ts", "../../../../@formkit/inputs/src/sections/message.ts", "../../../../@formkit/inputs/src/sections/messages.ts", "../../../../@formkit/inputs/src/sections/noFiles.ts", "../../../../@formkit/inputs/src/sections/optGroup.ts", "../../../../@formkit/inputs/src/sections/option.ts", "../../../../@formkit/inputs/src/sections/optionSlot.ts", "../../../../@formkit/inputs/src/sections/outer.ts", "../../../../@formkit/inputs/src/sections/prefix.ts", "../../../../@formkit/inputs/src/sections/selectInput.ts", "../../../../@formkit/inputs/src/sections/submitInput.ts", "../../../../@formkit/inputs/src/sections/suffix.ts", "../../../../@formkit/inputs/src/sections/textInput.ts", "../../../../@formkit/inputs/src/sections/textareaInput.ts", "../../../../@formkit/inputs/src/sections/wrapper.ts", "../../../../@formkit/inputs/src/features/renamesRadios.ts", "../../../../@formkit/inputs/src/features/checkboxes.ts", "../../../../@formkit/inputs/src/features/normalizeBoxes.ts", "../../../../@formkit/inputs/src/features/icon.ts", "../../../../@formkit/inputs/src/features/disables.ts", "../../../../@formkit/inputs/src/features/localize.ts", "../../../../@formkit/inputs/src/features/files.ts", "../../../../@formkit/inputs/src/features/forms.ts", "../../../../@formkit/inputs/src/features/ignores.ts", "../../../../@formkit/inputs/src/features/initialValue.ts", "../../../../@formkit/inputs/src/features/casts.ts", "../../../../@formkit/inputs/src/features/radios.ts", "../../../../@formkit/inputs/src/features/selects.ts", "../../../../@formkit/inputs/src/inputs/button.ts", "../../../../@formkit/inputs/src/inputs/checkbox.ts", "../../../../@formkit/inputs/src/inputs/file.ts", "../../../../@formkit/inputs/src/inputs/form.ts", "../../../../@formkit/inputs/src/inputs/group.ts", "../../../../@formkit/inputs/src/inputs/hidden.ts", "../../../../@formkit/inputs/src/inputs/list.ts", "../../../../@formkit/inputs/src/inputs/meta.ts", "../../../../@formkit/inputs/src/inputs/radio.ts", "../../../../@formkit/inputs/src/inputs/select.ts", "../../../../@formkit/inputs/src/inputs/textarea.ts", "../../../../@formkit/inputs/src/inputs/text.ts", "../../../../@formkit/inputs/src/index.ts", "../../../../@formkit/vue/node_modules/@formkit/themes/src/index.ts", "../../../../@formkit/dev/src/index.ts", "../../../../@formkit/vue/src/bindings.ts", "../../../../@formkit/vue/src/defaultConfig.ts", "../../../../@formkit/vue/src/FormKit.ts", "../../../../@formkit/vue/src/FormKitSchema.ts", "../../../../@formkit/vue/src/composables/onSSRComplete.ts", "../../../../@formkit/vue/src/FormKitRoot.ts", "../../../../@formkit/vue/src/composables/useInput.ts", "../../../../@formkit/vue/src/plugin.ts", "../../../../@formkit/vue/src/composables/createInput.ts", "../../../../@formkit/vue/src/composables/defineFormKitConfig.ts", "../../../../@formkit/vue/src/FormKitKitchenSink.ts", "../../../../@formkit/vue/src/FormKitMessages.ts", "../../../../@formkit/vue/src/FormKitProvider.ts", "../../../../@formkit/vue/src/composables/useContext.ts", "../../../../@formkit/vue/src/FormKitSummary.ts", "../../../../@formkit/vue/src/index.ts", "../../../../@formkit/vue/src/FormKitIcon.ts", "../../../../@formkit/vue/src/utilities/resetCount.ts"],
  "sourcesContent": ["import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value was should be considered \"accepted\".\n * @param context - The FormKitValidationContext\n * @public\n */\nconst accepted: FormKitValidationRule = function accepted({ value }) {\n  return ['yes', 'on', '1', 1, true, 'true'].includes(value as string)\n}\n\naccepted.skipEmpty = false\n\nexport default accepted\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is after a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after: FormKitValidationRule = function (\n  { value },\n  compare = false\n) {\n  const timestamp = Date.parse(compare || new Date())\n  const fieldValue = Date.parse(String(value))\n  return isNaN(fieldValue) ? false : fieldValue > timestamp\n}\n\nexport default date_after\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is after or equal to a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after_or_equal: FormKitValidationRule = function (\n  { value },\n  compare = false\n) {\n  const timestamp = Date.parse(compare || new Date())\n  const fieldValue = Date.parse(String(value))\n  return isNaN(fieldValue) ? false : fieldValue > timestamp || fieldValue === timestamp\n}\n\nexport default date_after_or_equal\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is after a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after_node: FormKitValidationRule = function (\n  node,\n  address: string\n) {\n  if (!address) return false\n\n  const fieldValue = Date.parse(String(node.value))\n  const foreignValue = Date.parse(String(node.at(address)?.value))\n\n  if (isNaN(foreignValue)) return true\n\n  return isNaN(fieldValue) ? false : fieldValue > foreignValue\n}\n\nexport default date_after_node\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha: FormKitValidationRule = function ({ value }, set = 'default') {\n  const sets = {\n    default: /^\\p{L}+$/u,\n    latin: /^[a-z]+$/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default alpha\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only alpha characters or space.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha_spaces: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /^[\\p{L} ]+$/u,\n    latin: /^[a-z ]+$/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default alpha_spaces\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only alpha or numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alphanumeric: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /^[0-9\\p{L}]+$/u,\n    latin: /^[0-9a-z]+$/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default alphanumeric\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is before a given date.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before: FormKitValidationRule = function (\n  { value },\n  compare = false\n) {\n  const timestamp = Date.parse(compare || new Date())\n  const fieldValue = Date.parse(String(value))\n  return isNaN(fieldValue) ? false : fieldValue < timestamp\n}\n\nexport default date_before\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is before a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before_node: FormKitValidationRule = function (\n  node,\n  address: string\n) {\n  if (!address) return false\n\n  const fieldValue = Date.parse(String(node.value))\n  const foreignValue = Date.parse(String(node.at(address)?.value))\n\n  if (isNaN(foreignValue)) return true\n\n  return isNaN(fieldValue) ? false : fieldValue < foreignValue\n}\n\nexport default date_before_node\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is before or equal to a given date.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before_or_equal: FormKitValidationRule = function (\n  { value },\n  compare = false\n) {\n  const timestamp = Date.parse(compare || new Date())\n  const fieldValue = Date.parse(String(value))\n  return isNaN(fieldValue) ? false : fieldValue < timestamp || fieldValue === timestamp\n}\n\nexport default date_before_or_equal\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is between two other values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst between: FormKitValidationRule = function between(\n  { value },\n  from: any,\n  to: any\n) {\n  if (!isNaN(value as number) && !isNaN(from) && !isNaN(to)) {\n    const val = 1 * (value as number)\n    from = Number(from)\n    to = Number(to)\n    const [a, b] = from <= to ? [from, to] : [to, from]\n    return val >= 1 * a && val <= 1 * b\n  }\n  return false\n}\n\nexport default between\n", "import { FormKitValidationRule } from '@formkit/validation'\n\nconst hasConfirm = /(_confirm(?:ed)?)$/\n\n/**\n * Determine if the given input's value matches another input's value.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst confirm: FormKitValidationRule = function confirm(\n  node,\n  address?,\n  comparison = 'loose'\n) {\n  if (!address) {\n    address = hasConfirm.test(node.name)\n      ? node.name.replace(hasConfirm, '')\n      : `${node.name}_confirm`\n  }\n  const foreignValue = node.at(address)?.value\n  return comparison === 'strict'\n    ? node.value === foreignValue\n    : node.value == foreignValue\n}\n\nexport default confirm\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_alpha: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /\\p{L}/u,\n    latin: /[a-z]/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_alpha\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains alpha characters or space.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_alpha_spaces: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /[\\p{L} ]/u,\n    latin: /[a-z ]/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_alpha_spaces\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains alpha or numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_alphanumeric: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /[0-9\\p{L}]/u,\n    latin: /[0-9a-z]/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_alphanumeric\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains lowercase characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_lowercase: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /\\p{Ll}/u,\n    latin: /[a-z]/,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_lowercase\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_numeric: FormKitValidationRule = function number({ value }) {\n  return /[0-9]/.test(String(value))\n}\n\nexport default contains_numeric\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains symbol characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_symbol: FormKitValidationRule = function ({ value }) {\n  return /[!-/:-@[-`{-~]/.test(String(value))\n}\n\nexport default contains_symbol\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains uppercase characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_uppercase: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /\\p{Lu}/u,\n    latin: /[A-Z]/,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_uppercase\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is between two other dates.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_between: FormKitValidationRule = function date_between(\n  { value },\n  dateA,\n  dateB\n) {\n  dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA)\n  dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB)\n  const compareTo =\n    value instanceof Date ? value.getTime() : Date.parse(String(value))\n  if (dateA && !dateB) {\n    dateB = dateA\n    dateA = Date.now()\n  } else if (!dateA || !compareTo) {\n    return false\n  }\n  return compareTo >= dateA && compareTo <= dateB\n}\n\nexport default date_between\n", "import { regexForFormat } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value matches a specified date format.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_format: FormKitValidationRule = function date(\n  { value },\n  format?: string\n) {\n  if (format && typeof format === 'string') {\n    return regexForFormat(format).test(String(value))\n  }\n  return !isNaN(Date.parse(String(value)))\n}\n\nexport default date_format\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is a plausible email address.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst email: FormKitValidationRule = function email({ value }) {\n  const isEmail = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i\n  return isEmail.test(String(value))\n}\n\nexport default email\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value ends with a given string.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst ends_with: FormKitValidationRule = function ends_with(\n  { value },\n  ...stack: string[]\n) {\n  if (typeof value === 'string' && stack.length) {\n    return stack.some((item) => {\n      return value.endsWith(item)\n    })\n  } else if (typeof value === 'string' && stack.length === 0) {\n    return true\n  }\n  return false\n}\n\nexport default ends_with\n", "import { eq } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is in a set of possible values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst is: FormKitValidationRule = function is({ value }, ...stack: any[]) {\n  return stack.some((item) => {\n    if (typeof item === 'object') {\n      return eq(item, value)\n    }\n    return item == value\n  })\n}\n\nexport default is\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value length is full width.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst length: FormKitValidationRule = function length(\n  { value },\n  first = 0,\n  second = Infinity\n) {\n  first = parseInt(first)\n  second = isNaN(parseInt(second)) ? Infinity : parseInt(second)\n  const min = first <= second ? first : second\n  const max = second >= first ? second : first\n  if (typeof value === 'string' || Array.isArray(value)) {\n    return value.length >= min && value.length <= max\n  } else if (value && typeof value === 'object') {\n    const length = Object.keys(value).length\n    return length >= min && length <= max\n  }\n  return false\n}\n\nexport default length\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only lowercase characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst lowercase: FormKitValidationRule = function ({ value }, set = 'default') {\n  const sets = {\n    default: /^\\p{Ll}+$/u,\n    allow_non_alpha: /^[0-9\\p{Ll}!-/:-@[-`{-~]+$/u,\n    allow_numeric: /^[0-9\\p{Ll}]+$/u,\n    allow_numeric_dashes: /^[0-9\\p{Ll}-]+$/u,\n    latin: /^[a-z]+$/,\n  }\n  const selectedSet: 'default' | 'allow_non_alpha' | 'allow_numeric' | 'allow_numeric_dashes' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default lowercase\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value matches one or more values or regular expressions.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst matches: FormKitValidationRule = function matches({ value }, ...stack) {\n  return stack.some((pattern) => {\n    if (\n      typeof pattern === 'string' &&\n      pattern.substr(0, 1) === '/' &&\n      pattern.substr(-1) === '/'\n    ) {\n      pattern = new RegExp(pattern.substr(1, pattern.length - 2))\n    }\n    if (pattern instanceof RegExp) {\n      return pattern.test(String(value))\n    }\n    return pattern === value\n  })\n}\n\nexport default matches\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is less than or equal to the maximum.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst max: FormKitValidationRule = function max({ value }, maximum = 10) {\n  if (Array.isArray(value)) {\n    return value.length <= maximum\n  }\n  return Number(value) <= Number(maximum)\n}\n\nexport default max\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is greater than or equal to the minimum.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst min: FormKitValidationRule = function min({ value }, minimum = 1) {\n  if (Array.isArray(value)) {\n    return value.length >= minimum\n  }\n  return Number(value) >= Number(minimum)\n}\n\nexport default min\n", "import { FormKitValidationRule } from '@formkit/validation'\nimport { eq } from '@formkit/utils'\n\n/**\n * Determine if the given input's value is not in a given stack.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst not: FormKitValidationRule = function not({ value }, ...stack) {\n  return !stack.some((item) => {\n    if (typeof item === 'object') {\n      return eq(item, value)\n    }\n    return item === value\n  })\n}\n\nexport default not\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is numeric.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst number: FormKitValidationRule = function number({ value }) {\n  return !isNaN(value as number)\n}\n\nexport default number\n", "import { empty } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if any of the given inputs have a value.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst require_one: FormKitValidationRule = function (\n  node,\n  ...inputNames: string[]\n) {\n  if (!empty(node.value)) return true\n\n  const values = inputNames.map(name => node.at(name)?.value)\n  return values.some(value => !empty(value))\n}\n\nrequire_one.skipEmpty = false\n\nexport default require_one\n", "import { empty } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is required.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst required: FormKitValidationRule = function required({ value }, action = 'default') {\n  return action === 'trim' && typeof value === 'string'\n    ? !empty(value.trim())\n    : !empty(value)\n}\n\n/**\n * This rules should run even if the inputs is empty (obviously)\n */\nrequired.skipEmpty = false\n\nexport default required\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value starts with a substring.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst starts_with: FormKitValidationRule = function starts_with(\n  { value },\n  ...stack\n) {\n  if (typeof value === 'string' && stack.length) {\n    return stack.some((item) => {\n      return value.startsWith(item)\n    })\n  } else if (typeof value === 'string' && stack.length === 0) {\n    return true\n  }\n  return false\n}\n\nexport default starts_with\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only symbol characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst symbol: FormKitValidationRule = function ({ value }) {\n  return /^[!-/:-@[-`{-~]+$/.test(String(value))\n}\n\nexport default symbol\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only uppercase characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst uppercase: FormKitValidationRule = function ({ value }, set = 'default') {\n  const sets = {\n    default: /^\\p{Lu}+$/u,\n    latin: /^[A-Z]+$/,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default uppercase\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is a URL.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst url: FormKitValidationRule = function url({ value }, ...stack) {\n  try {\n    const protocols = stack.length ? stack : ['http:', 'https:']\n    const url = new URL(String(value))\n    return protocols.includes(url.protocol)\n  } catch {\n    return false\n  }\n}\n\nexport default url\n", "import { camel, extend, has } from '@formkit/utils'\nimport { FormKitLibrary, FormKitPlugin, FormKitNode } from '@formkit/core'\n\n/**\n * Creates a plugin based on a list of {@link @formkit/core#FormKitLibrary | FormKitLibrary}.\n *\n * @param libraries - One or many {@link @formkit/core#FormKitLibrary | FormKitLibrary}.\n *\n * @returns {@link @formkit/core#FormKitPlugin | FormKitPlugin}\n *\n * @public\n */\nexport function createLibraryPlugin(\n  ...libraries: FormKitLibrary[]\n): FormKitPlugin {\n  /**\n   * Merge all provided library items.\n   */\n  const library = libraries.reduce(\n    (merged, lib) => extend(merged, lib) as FormKitLibrary,\n    {} as FormKitLibrary\n  )\n  /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n  const plugin = () => {}\n  /**\n   * Enables the hook that exposes all library inputs.\n   * @param node - The primary plugin\n   */\n  plugin.library = function (node: FormKitNode) {\n    const type = camel(node.props.type)\n    if (has(library, type)) {\n      node.define(library[type])\n    }\n  }\n  return plugin\n}\n", "import {\n  FormKitPlugin,\n  FormKitGroupValue,\n  FormKitTypeDefinition,\n  FormKitSectionsSchema,\n  FormKitNode,\n  FormKitClasses,\n  FormKitFrameworkContext,\n  FormKitMessage,\n} from '@formkit/core'\nimport { FormKitFile } from './index'\n\n/**\n * These are props that are used as conditionals in one or more inputs, and as\n * such they need to be defined on all input types. These should all be defined\n * explicitly as \"undefined\" here, and then defined as their specific type\n * in the FormKitInputProps interface only on the inputs that use them.\n * @public\n */\nexport interface FormKitConditionalProps {\n  onValue: undefined\n  offValue: undefined\n  options: undefined\n  number: undefined\n}\n\n/**\n * An attempt to capture all non-undefined values. This is used to define\n * various conditionals where undefined is not a concrete type, but all other\n * values need to take one logical branch.\n *\n * @public\n */\nexport type AllReals =\n  | number\n  | string\n  | boolean\n  | CallableFunction\n  | Array<any>\n  | null\n  | Record<any, any>\n/**\n * This is the base interface for providing prop definitions to the FormKit\n * component. It is used to define the props that are available to the each\n * component in the FormKit library by using a discriminated union type. The\n * structure of this interface is:\n *\n * ```ts\n * interface FormKitInputProps {\n *  typeString: { type: 'string'; value?: string } // <-- All unique props\n * }\n * ```\n *\n * All inputs will also inherit all props from FormKitBaseInputProps.\n *\n * Note: It is important that all inputs provide a type and a value prop.\n * @public\n */\nexport interface FormKitInputProps<Props extends FormKitInputs<Props>> {\n  button: { type: 'button'; value?: undefined }\n  checkbox: {\n    type: 'checkbox'\n    options?: FormKitOptionsProp\n    onValue?: any\n    offValue?: any\n    value?: Props['options'] extends Record<infer T, string>\n      ? T[]\n      : Props['options'] extends FormKitOptionsItem[]\n      ? Array<Props['options'][number]['value']>\n      : Props['options'] extends Array<infer T>\n      ? T[]\n      :\n          | (Props['onValue'] extends AllReals ? Props['onValue'] : true)\n          | (Props['offValue'] extends AllReals ? Props['offValue'] : false)\n  }\n  color: { type: 'color'; value?: string }\n  date: { type: 'date'; value?: string }\n  'datetime-local': { type: 'datetime-local'; value?: string }\n  email: {\n    type: 'email'\n    value?: string\n  }\n  file: { type: 'file'; value?: FormKitFile[] }\n  form: {\n    type: 'form'\n    value?: FormKitGroupValue\n    actions?: boolean | string\n    submitAttrs?: Record<string, any>\n    submitBehavior?: 'disabled' | 'live'\n    incompleteMessage?: false | string\n  }\n  group: { type: 'group'; value?: FormKitGroupValue }\n  hidden: {\n    type: 'hidden'\n    value?: Props['number'] extends AllReals ? number : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  list: {\n    type: 'list'\n    value?: unknown[]\n    dynamic?: boolean | 'true' | 'false'\n    sync?: boolean | 'true' | 'false'\n  }\n  meta: { type: 'meta'; value?: any }\n  month: { type: 'month'; value?: string }\n  number: {\n    type: 'number'\n    value?: Props['number'] extends AllReals ? number : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  password: { type: 'password'; value?: string }\n  radio: {\n    type: 'radio'\n    options: FormKitOptionsProp\n    value?: FormKitOptionsValue<Props['options']>\n  }\n  range: {\n    type: 'range'\n    value?: Props['number'] extends AllReals ? number : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  search: {\n    type: 'search'\n    value?: Props['number'] extends AllReals ? number | string : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  select: {\n    type: 'select'\n    options?: FormKitOptionsPropWithGroups\n    value?: FormKitOptionsValue<Props['options']>\n  }\n  submit: { type: 'submit'; value?: string }\n  tel: {\n    type: 'tel'\n    value?: Props['number'] extends AllReals ? number | string : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  text: {\n    type: 'text'\n    value?: Props['number'] extends AllReals ? number | string : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  textarea: { type: 'textarea'; value?: string }\n  time: { type: 'time'; value?: string }\n  url: { type: 'url'; value?: string }\n  week: { type: 'week'; value?: string }\n  // This fallthrough is for inputs that do not have their type set. These\n  // are effectively \"text\" inputs.\n  _: {\n    type?:\n      | (Props['type'] extends FormKitTypeDefinition<any>\n          ? Props['type']\n          : never & {})\n      | (Props['type'] extends keyof FormKitInputProps<Props>\n          ? Props['type']\n          : never)\n    value?: Props['type'] extends FormKitTypeDefinition<infer T>\n      ? T\n      : Props['type'] extends AllReals\n      ? never\n      : string\n  }\n}\n\n/**\n * A merger of input props, base props, and conditional props. This is then\n * used as the structure for the FormKitInputs type.\n * @public\n */\nexport type MergedProps<Props extends FormKitInputs<Props>> = {\n  [K in keyof FormKitInputProps<Props>]: Omit<\n    Partial<FormKitBaseProps>,\n    keyof FormKitInputProps<Props>[K]\n  > &\n    Omit<\n      Partial<FormKitRuntimeProps<Props>>,\n      keyof FormKitInputProps<Props>[K]\n    > &\n    Omit<Partial<FormKitConditionalProps>, keyof FormKitInputProps<Props>[K]> &\n    Partial<\n      K extends keyof FormKitInputEventsAsProps<Props>\n        ? Omit<\n            FormKitEventsAsProps,\n            keyof FormKitInputEventsAsProps<Props>[K]\n          > &\n            FormKitInputEventsAsProps<Props>[K]\n        : FormKitEventsAsProps\n    > &\n    FormKitInputProps<Props>[K]\n}\n\n/**\n * Merge all events into a single type. This is then used as the structure for\n *\n * @public\n */\nexport type MergedEvents<Props extends FormKitInputs<Props>> =\n  InputType<Props> extends keyof FormKitInputEvents<Props>\n    ? FormKitBaseEvents<Props> & FormKitInputEvents<Props>[InputType<Props>]\n    : FormKitBaseEvents<Props>\n\n/**\n * Selects the \"type\" from the props if it exists, otherwise it defaults to\n * \"text\".\n *\n * @public\n */\nexport type InputType<Props extends FormKitInputs<Props>> =\n  Props['type'] extends FormKitTypeDefinition<any>\n    ? Props['type']\n    : Props['type'] extends string\n    ? Props['type']\n    : 'text'\n\n/**\n * All FormKit events should be included for a given set of props.\n *\n * @public\n */\nexport type FormKitEvents<Props extends FormKitInputs<Props>> =\n  MergedEvents<Props>\n\n/**\n * All FormKit inputs should be included for this type.\n * @public\n */\nexport type FormKitInputs<Props extends FormKitInputs<Props>> =\n  MergedProps<Props>[keyof MergedProps<Props>]\n\n/**\n * Unique events emitted by each FormKit input. The shape of this interface is:\n *\n * ```ts\n * interface FormKitInputEvents<Props extends Inputs> {\n *   typeString: { customEvent: (value: PropType<Props, 'value'>) => any } // <-- All unique events\n * }\n * ```\n *\n * All inputs will also inherit all events from FormKitBaseInputEvents.\n * @public\n */\nexport interface FormKitInputEvents<Props extends FormKitInputs<Props>> {\n  form: {\n    (event: 'submit-raw', e: Event, node: FormKitNode): any\n    (event: 'submit-invalid', node: FormKitNode): any\n    (event: 'submit', data: any, node: FormKitNode): any\n  }\n}\n\n/**\n * Extracts the type from a given prop.\n * @public\n */\nexport type PropType<\n  Props extends FormKitInputs<Props>,\n  T extends keyof FormKitInputs<Props>\n> = Props['type'] extends FormKitTypeDefinition<infer T>\n  ? T extends 'value'\n    ? Props['type']\n    : T\n  : Extract<\n      FormKitInputs<Props>,\n      {\n        type: Props['type'] extends keyof FormKitInputProps<Props>\n          ? Props['type']\n          : 'text'\n      }\n    >[T]\n\n/**\n * The proper shape of data to be passed to options prop.\n * @public\n */\nexport type FormKitOptionsValue<Options> = Options extends FormKitOptionsProp\n  ? Options extends Record<infer T, string>\n    ? T\n    : Options extends FormKitOptionsItem[]\n    ? Options[number]['value']\n    : Options extends Array<infer T>\n    ? T\n    : unknown\n  : unknown\n\n/**\n * General input events available to all FormKit inputs.\n * @public\n */\nexport interface FormKitBaseEvents<Props extends FormKitInputs<Props>> {\n  (event: 'input', value: PropType<Props, 'value'>, node: FormKitNode): any\n  (event: 'inputRaw', value: PropType<Props, 'value'>, node: FormKitNode): any\n  (event: 'input-raw', value: PropType<Props, 'value'>, node: FormKitNode): any\n  (event: 'update:modelValue', value: PropType<Props, 'value'>): any\n  (event: 'update:model-value', value: PropType<Props, 'value'>): any\n  (event: 'node', node: FormKitNode): any\n}\n\n/**\n * In a perfect world this interface would not be required at all. However, Vue\n * expects the interfaces to be defined as method overloads. Unfortunately since\n * our events interface uses generics UnionToIntersection is not able to be used\n * meaning that we lose event data if we store the events as a standard\n * interface with property keys. The only way we have found to reliably get\n * Volar (as of June 2023) to properly recognize all defined events is to use\n * a the \"standard\" method overload approach (see FormKitBaseEvents).\n *\n * (Basically we cannot use the events in this interface to automatically\n * produce the FormKitBaseEvents without Volar loosing event data)\n *\n * This means we have no way to get the event names out of the interface so we\n * cannot properly use them in our props. This matters for things like TSX\n * support where the event names need to be available as `onEventName` props.\n *\n * This interface is used to manually patch that gap in the type system. These\n * types should match up 1-1 with the events defined in FormKitBaseEvents as\n * well as FormKitInputEvents.\n *\n * @public\n */\nexport interface FormKitEventsAsProps {\n  onInput: (value: unknown, node: FormKitNode) => any\n  onInputRaw: (value: unknown, node: FormKitNode) => any\n  'onUpdate:modelValue': (value: unknown, node: FormKitNode) => any\n  onNode: (node: FormKitNode) => any\n}\n\n/**\n * See the comment tome on {@link FormKitEventsAsProps} for why this type is\n * necessary.\n *\n * @public\n */\nexport interface FormKitInputEventsAsProps<Props extends FormKitInputs<Props>> {\n  form: {\n    onSubmitRaw: (e: Event, node: FormKitNode) => any\n    onSubmitInvalid: (node: FormKitNode) => any\n    onSubmit: (data: any, node: FormKitNode) => any\n  }\n}\n\n/**\n * The shape of the context object that is passed to each slot.\n * @public\n */\nexport interface FormKitSlotData<\n  Props extends FormKitInputs<Props>,\n  E extends Record<string, any> = {}\n> {\n  (context: FormKitFrameworkContext<PropType<Props, 'value'>> & E): any\n}\n\n/**\n * Nearly all inputs in FormKit have a \"base\" set of slots. This is the\n * \"sandwich\" around the input itself, like the wrappers, help text, error\n * messages etc. Several other input’s slots extend this base interface.\n * @public\n */\nexport interface FormKitBaseSlots<Props extends FormKitInputs<Props>> {\n  help: FormKitSlotData<Props>\n  inner: FormKitSlotData<Props>\n  input: FormKitSlotData<Props>\n  label: FormKitSlotData<Props>\n  message: FormKitSlotData<Props, { message: FormKitMessage }>\n  messages: FormKitSlotData<Props>\n  outer: FormKitSlotData<Props>\n  prefix: FormKitSlotData<Props>\n  prefixIcon: FormKitSlotData<Props>\n  suffix: FormKitSlotData<Props>\n  suffixIcon: FormKitSlotData<Props>\n  wrapper: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the FormKitText input, these extend the base slots.\n * @public\n */\nexport interface FormKitTextSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {}\n\n/**\n * The data available to slots that have an option in scope.\n * @public\n */\nexport interface OptionSlotData<Props extends FormKitInputs<Props>> {\n  option: FormKitOptionsItem<PropType<Props, 'value'>>\n}\n\n/**\n * The slots available to the select input, these extend the base slots.\n * @public\n */\nexport interface FormKitSelectSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {\n  default: FormKitSlotData<Props>\n  option: FormKitSlotData<Props, OptionSlotData<Props>>\n  selectIcon: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the checkbox inputs even when options are not provided, these extend the base slots.\n * @public\n */\nexport interface FormKitCheckboxSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {\n  decorator: FormKitSlotData<Props, OptionSlotData<Props>>\n  decoratorIcon: FormKitSlotData<Props, OptionSlotData<Props>>\n}\n\n/**\n * The slots available to the radio and checkbox inputs when options are\n * provided.\n * @public\n */\nexport interface FormKitBoxSlots<Props extends FormKitInputs<Props>> {\n  fieldset: FormKitSlotData<Props>\n  legend: FormKitSlotData<Props>\n  help: FormKitSlotData<Props>\n  options: FormKitSlotData<Props>\n  option: FormKitSlotData<Props, OptionSlotData<Props>>\n  wrapper: FormKitSlotData<Props, OptionSlotData<Props>>\n  inner: FormKitSlotData<Props, OptionSlotData<Props>>\n  input: FormKitSlotData<Props, OptionSlotData<Props>>\n  label: FormKitSlotData<Props, OptionSlotData<Props>>\n  prefix: FormKitSlotData<Props, OptionSlotData<Props>>\n  suffix: FormKitSlotData<Props, OptionSlotData<Props>>\n  decorator: FormKitSlotData<Props, OptionSlotData<Props>>\n  decoratorIcon: FormKitSlotData<Props, OptionSlotData<Props>>\n  optionHelp: FormKitSlotData<Props, OptionSlotData<Props>>\n  box: FormKitSlotData<Props, OptionSlotData<Props>>\n  icon: FormKitSlotData<Props, OptionSlotData<Props>>\n  message: FormKitSlotData<Props, { message: FormKitMessage }>\n  messages: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the file input, these extend the base slots.\n * @public\n */\nexport interface FormKitFileSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {\n  fileList: FormKitSlotData<Props>\n  fileItem: FormKitSlotData<Props>\n  fileItemIcon: FormKitSlotData<Props, { file: FormKitFile }>\n  fileName: FormKitSlotData<Props, { file: FormKitFile }>\n  fileRemove: FormKitSlotData<Props, { file: FormKitFile }>\n  fileRemoveIcon: FormKitSlotData<Props, { file: FormKitFile }>\n  noFiles: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the button input, these extend the base slots.\n *\n * @public\n */\nexport type FormKitButtonSlots<Props extends FormKitInputs<Props>> = Omit<\n  FormKitBaseSlots<Props>,\n  'inner'\n> & {\n  default: FormKitSlotData<Props>\n}\n\n/**\n * Slots provided by each FormKit input. The shape of this interface is:\n *\n * ```ts\n * interface FormKitInputSlots<Props extends Inputs> {\n *   typeString: { default: (value: PropType<Props, 'value'>) => any } // <-- All unique slots\n * }\n * ```\n *\n * There is no automatic inheritance of slots — each slot must be explicitly\n * defined for each input.\n * @public\n */\nexport interface FormKitInputSlots<Props extends FormKitInputs<Props>> {\n  text: FormKitTextSlots<Props>\n  color: FormKitTextSlots<Props>\n  date: FormKitTextSlots<Props>\n  'datetime-local': FormKitTextSlots<Props>\n  email: FormKitTextSlots<Props>\n  month: FormKitTextSlots<Props>\n  number: FormKitTextSlots<Props>\n  password: FormKitTextSlots<Props>\n  search: FormKitTextSlots<Props>\n  tel: FormKitTextSlots<Props>\n  time: FormKitTextSlots<Props>\n  url: FormKitTextSlots<Props>\n  week: FormKitTextSlots<Props>\n  range: FormKitTextSlots<Props>\n  // Technically textarea has a unique schema, but the slots are the same:\n  textarea: FormKitTextSlots<Props>\n  select: FormKitSelectSlots<Props>\n  radio: Props['options'] extends AllReals\n    ? FormKitBoxSlots<Props>\n    : FormKitBaseSlots<Props>\n  list: { default: FormKitSlotData<Props> }\n  hidden: { input: FormKitSlotData<Props> }\n  meta: { wrapper: FormKitSlotData<Props> }\n  group: { default: FormKitSlotData<Props> }\n  form: {\n    form: FormKitSlotData<Props>\n    default: FormKitSlotData<Props>\n    message: FormKitSlotData<Props, { message: FormKitMessage }>\n    messages: FormKitSlotData<Props>\n    actions: FormKitSlotData<Props>\n    submit: FormKitSlotData<Props>\n  }\n  file: FormKitFileSlots<Props>\n  checkbox: Props['options'] extends AllReals\n    ? FormKitBoxSlots<Props>\n    : FormKitCheckboxSlots<Props>\n  submit: FormKitButtonSlots<Props>\n  button: FormKitButtonSlots<Props>\n}\n\n/**\n * Options should always be formatted as an array of objects with label and value\n * properties.\n *\n * @public\n */\nexport interface FormKitOptionsItem<V = unknown> {\n  label: string\n  value: V\n  attrs?: {\n    disabled?: boolean\n  } & Record<string, any>\n  __original?: any\n  [index: string]: any\n}\n\n/**\n * Option groups should always be formatted as an array of objects with group and nested options\n *\n * @public\n */\nexport interface FormKitOptionsGroupItemProp {\n  group: string\n  options: FormKitOptionsProp\n  attrs?: Record<string, any>\n}\n\n/**\n * Option groups should always be formatted as an array of objects with group and nested options\n *\n * @public\n */\nexport interface FormKitOptionsGroupItem {\n  group: string\n  options: FormKitOptionsList\n  attrs?: Record<string, any>\n}\n\n/**\n * An array of option items.\n *\n * @public\n */\nexport type FormKitOptionsList = FormKitOptionsItem[]\n\n/**\n * An array of option items with a group.\n *\n * @public\n */\nexport type FormKitOptionsListWithGroups = Array<\n  FormKitOptionsItem | FormKitOptionsGroupItem\n>\n\n/**\n * An array of option items with a group support — where the `option` of the\n * groups can be any valid FormKitOptionsProp type.\n *\n * @public\n */\nexport type FormKitOptionsListWithGroupsProp = Array<\n  FormKitOptionsItem | FormKitOptionsGroupItemProp\n>\n\n/**\n * Allows for prop extensions to be defined by using an interface whose keys\n * are ignored, but values are applied to a union type. This allows for any\n * third party code to extend the options prop by using module augmentation\n * to add new values to the union type.\n *\n * @public\n */\nexport interface FormKitOptionsPropExtensions {\n  arrayOfStrings: string[]\n  arrayOfNumbers: number[]\n  optionsList: FormKitOptionsList\n  valueLabelPojo: Record<string | number, string>\n}\n\n/**\n * The types of options that can be passed to the options prop.\n *\n * @public\n */\nexport type FormKitOptionsProp =\n  FormKitOptionsPropExtensions[keyof FormKitOptionsPropExtensions]\n\n/**\n * The types of options that can be passed to the options prop.\n *\n * @public\n */\nexport type FormKitOptionsPropWithGroups =\n  | FormKitOptionsProp\n  | FormKitOptionsListWithGroupsProp\n\n/**\n * Typings for all the built in runtime props.\n *\n * Warning: As of writing these are only specific to Vue’s runtime prop\n * requirements and should not be used as any kind of external API as they are\n * subject to change.\n *\n * @public\n */\nexport interface FormKitRuntimeProps<\n  Props extends FormKitInputs<Props>,\n  V = unknown\n> {\n  /**\n   * An object of configuration data for the input and its children.\n   */\n  config: Record<string, any>\n  /**\n   * An object of classes to be applied to the input.\n   */\n  classes: Record<string, string | Record<string, boolean> | FormKitClasses>\n  /**\n   * Amount of time to debounce input before committing.\n   */\n  delay: number\n  /**\n   * An array of errors for the input.\n   */\n  errors: string[]\n  /**\n   * A object of values\n   */\n  inputErrors: Record<string, string[]>\n  /**\n   * An explicit index to mount a child of a list at.\n   */\n  index: number\n  /**\n   * A globally unique identifier for the input — this passes through to the\n   * id attribute.\n   */\n  id: string\n  /**\n   * The dynamic value of the input.\n   */\n  modelValue: PropType<Props, 'value'>\n  /**\n   * The name of the input.\n   */\n  name: string\n  /**\n   * An explicit parent node for the input.\n   */\n  parent: FormKitNode\n  /**\n   * An array of plugins to apply to the input.\n   */\n  plugins: FormKitPlugin[]\n  /**\n   * An object of sections to merge with the input’s internal schema.\n   */\n  sectionsSchema: FormKitSectionsSchema\n  /**\n   * A boolean indicating whether the input should be synced with the model.\n   */\n  sync: boolean | undefined\n  /**\n   * The type of the input.\n   */\n  type: string | FormKitTypeDefinition<V>\n  /**\n   * A validation string or array of validation rules.\n   */\n  validation: string | Array<[rule: string, ...args: any]>\n  /**\n   * An object of validation messages to use for the input.\n   */\n  validationMessages: Record<\n    string,\n    string | ((ctx: { node: FormKitNode; name: string; args: any[] }) => string)\n  >\n  /**\n   * An object of additional validation rules to use for the input.\n   */\n  validationRules: Record<\n    string,\n    (node: FormKitNode, ...args: any[]) => boolean | Promise<boolean>\n  >\n  /**\n   * Use this to override the default validation label in validation messages.\n   */\n  validationLabel: string | ((node: FormKitNode) => string)\n}\n\n/**\n * Base props that should be applied to all FormKit inputs. These are not actual\n * runtime props and are pulled from the context.attrs object. Many of these are\n * just html attributes that are passed through to the input element.\n *\n * @public\n */\nexport interface FormKitBaseProps {\n  /**\n   * HTML Attribute, read more here: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#accept\n   */\n  accept: string\n  action: string\n  actions: 'true' | 'false' | boolean\n  dirtyBehavior: 'touched' | 'compare'\n  disabled: 'true' | 'false' | boolean\n  enctype: string\n  help: string\n  ignore: 'true' | 'false' | boolean\n  label: string\n  library: Record<string, any>\n  max: string | number\n  method: string\n  min: string | number\n  multiple: 'true' | 'false' | boolean\n  preserve: 'true' | 'false' | boolean\n  preserveErrors: 'true' | 'false' | boolean\n  placeholder: string\n  step: string | number\n  validationVisibility: 'live' | 'blur' | 'dirty' | 'submit'\n}\n\n/**\n * All the explicit FormKit props that need to be passed to FormKit’s Vue\n * component instance.\n * @public\n */\nexport const runtimeProps = [\n  'classes',\n  'config',\n  'delay',\n  'errors',\n  'id',\n  'index',\n  'inputErrors',\n  'library',\n  'modelValue',\n  'onUpdate:modelValue',\n  'name',\n  'number',\n  'parent',\n  'plugins',\n  'sectionsSchema',\n  'type',\n  'validation',\n  'validationLabel',\n  'validationMessages',\n  'validationRules',\n  // Runtime event props:\n  'onInput',\n  'onInputRaw',\n  'onUpdate:modelValue',\n  'onNode',\n  'onSubmit',\n  'onSubmitInvalid',\n  'onSubmitRaw',\n]\n\n/**\n * A helper to determine if an option is a group or an option.\n * @param option - An option\n *\n * @public\n */\nexport function isGroupOption(\n  option:\n    | FormKitOptionsItem\n    | FormKitOptionsGroupItem\n    | FormKitOptionsGroupItemProp\n): option is FormKitOptionsGroupItem {\n  return (\n    option &&\n    typeof option === 'object' &&\n    'group' in option &&\n    Array.isArray(option.options)\n  )\n}\n", "import { FormKitNode } from '@formkit/core'\nimport {\n  FormKitOptionsPropWithGroups,\n  FormKitOptionsListWithGroups,\n  FormKitOptionsItem,\n  FormKitOptionsGroupItem,\n  FormKitOptionsList,\n  FormKitOptionsProp,\n  isGroupOption,\n} from '../props'\nimport { eq, isPojo } from '@formkit/utils'\n\n/**\n * A function to normalize an array of objects, array of strings, or object of\n * key-values to use an array of objects with value and label properties.\n *\n * @param options - An un-normalized {@link FormKitOptionsProp | FormKitOptionsProp}.\n *\n * @returns A list of {@link FormKitOptionsList | FormKitOptionsList}.\n *\n * @public\n */\nexport function normalizeOptions<T extends FormKitOptionsPropWithGroups>(\n  options: T,\n  i = { count: 1 }\n): T extends FormKitOptionsProp\n  ? FormKitOptionsList\n  : FormKitOptionsListWithGroups {\n  if (Array.isArray(options)) {\n    return options.map(\n      (option): FormKitOptionsItem | FormKitOptionsGroupItem => {\n        if (typeof option === 'string' || typeof option === 'number') {\n          return {\n            label: String(option),\n            value: String(option),\n          }\n        }\n        if (typeof option == 'object') {\n          if ('group' in option) {\n            option.options = normalizeOptions(option.options || [], i)\n            return option as FormKitOptionsGroupItem\n          } else if ('value' in option && typeof option.value !== 'string') {\n            Object.assign(option, {\n              value: `__mask_${i.count++}`,\n              __original: option.value,\n            })\n          }\n        }\n        return option as FormKitOptionsItem\n      }\n    ) as any\n  }\n  return Object.keys(options).map((value: string) => {\n    return {\n      label: options[value],\n      value,\n    }\n  })\n}\n\n/**\n * Given an {@link FormKitOptionsList | FormKitOptionsListWithGroups}, find the real value in the options.\n *\n * @param options - The {@link FormKitOptionsList | FormKitOptionsListWithGroups} to check for a given value\n * @param value - The value to return\n *\n * @returns `unknown`\n *\n * @public\n */\nexport function optionValue(\n  options: FormKitOptionsListWithGroups,\n  value: string,\n  undefinedIfNotFound = false\n): unknown {\n  if (Array.isArray(options)) {\n    for (const option of options) {\n      if (typeof option !== 'object' && option) continue\n      if (isGroupOption(option)) {\n        const found = optionValue(option.options, value, true)\n        if (found !== undefined) {\n          return found\n        }\n      } else if (value == option.value) {\n        return '__original' in option ? option.__original : option.value\n      }\n    }\n  }\n  return undefinedIfNotFound ? undefined : value\n}\n\n/**\n * Determines if the value should be selected.\n *\n * @param valueA - Any type of value\n * @param valueB - Any type of value\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function shouldSelect(valueA: unknown, valueB: unknown): boolean {\n  if (\n    (valueA === null && valueB === undefined) ||\n    (valueA === undefined && valueB === null)\n  )\n    return false\n  if (valueA == valueB) return true\n  if (isPojo(valueA) && isPojo(valueB)) return eq(valueA, valueB)\n  return false\n}\n\n/**\n * A feature that converts the options prop to usable values, to be used by a\n * feature or a plugin.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function options(node: FormKitNode): void {\n  node.hook.prop((prop: any, next: any) => {\n    if (prop.prop === 'options') {\n      if (typeof prop.value === 'function') {\n        node.props.optionsLoader = prop.value\n        prop.value = []\n      } else {\n        node.props._normalizeCounter ??= { count: 1 }\n        prop.value = normalizeOptions(prop.value, node.props._normalizeCounter)\n      }\n    }\n    return next(prop)\n  })\n}\n", "import { extend } from '@formkit/utils'\nimport {\n  FormKitSchemaNode,\n  FormKitExtendableSchemaRoot,\n  isDOM,\n  isComponent,\n  FormKitSchemaDOMNode,\n  FormKitSchemaComponent,\n  FormKitSchemaFormKit,\n  FormKitSectionsSchema,\n  FormKitSchemaCondition,\n} from '@formkit/core'\n\n/**\n * A function that is called with an extensions argument and returns a valid\n * schema node.\n *\n * @public\n */\nexport interface FormKitSchemaExtendableSection {\n  (extensions: FormKitSectionsSchema): FormKitSchemaNode\n  _s?: string\n}\n\n/**\n * A function that when called, returns a function that can in turn be called\n * with an extension parameter.\n *\n * @public\n */\nexport interface FormKitSection<T = FormKitSchemaExtendableSection> {\n  (\n    ...children: Array<\n      FormKitSchemaExtendableSection | string | FormKitSchemaCondition\n    >\n  ): T\n}\n\n/**\n * Creates a new reusable section.\n *\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n * @param root - When true, returns a FormKitExtendableSchemaRoot. When false,\n * returns a FormKitSchemaExtendableSection.\n *\n * @returns Returns a {@link @formkit/core#FormKitExtendableSchemaRoot\n * | FormKitExtendableSchemaRoot} or a {@link\n * @formkit/core#FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}.\n *\n * @public\n */\nexport function createSection(\n  section: string,\n  el: string | null | (() => FormKitSchemaNode),\n  fragment: true\n): FormKitSection<FormKitExtendableSchemaRoot>\n\n/**\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n *\n * @public\n */\nexport function createSection(\n  section: string,\n  el: string | null | (() => FormKitSchemaNode)\n): FormKitSection<FormKitSchemaExtendableSection>\n\n/**\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n * @param root - When false, returns a FormKitSchemaExtendableSection.\n *\n * @public\n */\nexport function createSection(\n  section: string,\n  el: string | (() => FormKitSchemaNode),\n  fragment: false\n): FormKitSection<FormKitSchemaExtendableSection>\n\n/*@__NO_SIDE_EFFECTS__*/\nexport function createSection(\n  section: string,\n  el: string | null | (() => FormKitSchemaNode),\n  fragment = false\n): FormKitSection<\n  FormKitExtendableSchemaRoot | FormKitSchemaExtendableSection\n> {\n  return (\n    ...children: Array<\n      FormKitSchemaExtendableSection | string | FormKitSchemaCondition\n    >\n  ) => {\n    const extendable = (extensions: FormKitSectionsSchema) => {\n      const node = !el || typeof el === 'string' ? { $el: el } : el()\n      if (isDOM(node) || isComponent(node)) {\n        if (!node.meta) {\n          node.meta = { section }\n        } else {\n          node.meta.section = section\n        }\n        if (children.length && !node.children) {\n          node.children = [\n            ...children.map((child) =>\n              typeof child === 'function' ? child(extensions) : child\n            ),\n          ]\n        }\n        if (isDOM(node)) {\n          node.attrs = {\n            class: `$classes.${section}`,\n            ...(node.attrs || {}),\n          }\n        }\n      }\n      return {\n        if: `$slots.${section}`,\n        then: `$slots.${section}`,\n        else:\n          section in extensions\n            ? extendSchema(node, extensions[section])\n            : node,\n      }\n    }\n    extendable._s = section\n    return fragment ? createRoot(extendable) : extendable\n  }\n}\n\n/**\n * Returns an extendable schema root node.\n *\n * @param rootSection - Creates the root node.\n *\n * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}\n *\n * @internal\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function createRoot(\n  rootSection: FormKitSchemaExtendableSection\n): FormKitExtendableSchemaRoot {\n  return (extensions: FormKitSectionsSchema) => {\n    return [rootSection(extensions)]\n  }\n}\n\n/**\n * Type guard for schema objects.\n *\n * @param schema - returns `true` if the node is a schema node but not a string\n * or conditional.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isSchemaObject(\n  schema: Partial<FormKitSchemaNode> | null\n): schema is\n  | FormKitSchemaDOMNode\n  | FormKitSchemaComponent\n  | FormKitSchemaFormKit {\n  return !!(\n    schema &&\n    typeof schema === 'object' &&\n    ('$el' in schema || '$cmp' in schema || '$formkit' in schema)\n  )\n}\n\n/**\n * Extends a single schema node with an extension. The extension can be any\n * partial node including strings.\n *\n * @param schema - The base schema node.\n * @param extension - The values to extend on the base schema node.\n *\n * @returns {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function extendSchema(\n  schema: FormKitSchemaNode,\n  extension: Partial<FormKitSchemaNode> | null = {}\n): FormKitSchemaNode {\n  if (typeof schema === 'string') {\n    return isSchemaObject(extension) || typeof extension === 'string'\n      ? extension\n      : schema\n  } else if (Array.isArray(schema)) {\n    return isSchemaObject(extension) ? extension : schema\n  }\n  return extend(schema, extension) as FormKitSchemaNode\n}\n", "import { extend, isObject, token } from '@formkit/utils'\nimport {\n  FormKitExtendableSchemaRoot,\n  FormKitSchemaAttributes,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n  FormKitSchemaDefinition,\n  FormKitSchemaComponent,\n  isComponent,\n  isDOM,\n  isConditional,\n  warn,\n  FormKitSchemaDOMNode,\n  FormKitSectionsSchema,\n} from '@formkit/core'\nimport {\n  isSchemaObject,\n  extendSchema,\n  FormKitSection,\n  FormKitSchemaExtendableSection,\n  createRoot,\n} from './createSection'\nimport {\n  outer,\n  wrapper,\n  prefix,\n  suffix,\n  label,\n  inner,\n  messages,\n  message,\n  help,\n  icon,\n} from './sections'\nimport { resetRadio } from './features/renamesRadios'\n\n/**\n * Either a schema node, or a function that returns a schema node.\n *\n * @public\n */\nexport type FormKitInputSchema =\n  | ((children?: FormKitSchemaDefinition) => FormKitSchemaNode)\n  | FormKitSchemaNode\n\n/**\n * A type narrowed type that represents a formkit schema \"section\". These are\n * always in the shape:\n * ```js\n * {\n *   if: string,\n *   then: '$slots.sectionName',\n *   else: {\n *    meta: {\n *      section: 'sectionName'\n *    },\n *    $el: 'div' // or $cmp...\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type FormKitSchemaSection = FormKitSchemaCondition & {\n  else:\n    | FormKitSchemaDOMNode\n    | (FormKitSchemaComponent & { meta: { section: string } })\n}\n\n/**\n * Checks if the current schema node is a slot condition.\n *\n * @example\n *\n * ```js\n * {\n *  if: '$slot.name',\n *  then: '$slot.name',\n *  else: []\n * } // this schema node would return true.\n * ```\n *\n * @param node - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}.\n *\n * @returns `boolean`\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function isSlotCondition(node: FormKitSchemaNode): node is {\n  if: string\n  then: string\n  else: FormKitSchemaNode | FormKitSchemaNode[]\n} {\n  if (\n    isConditional(node) &&\n    node.if &&\n    node.if.startsWith('$slots.') &&\n    typeof node.then === 'string' &&\n    node.then.startsWith('$slots.') &&\n    'else' in node\n  ) {\n    return true\n  }\n  return false\n}\n\n/**\n * Finds a section by name in a schema.\n *\n * @param schema - A {@link @formkit/core#FormKitSchemaDefinition | FormKitSchemaDefinition} array.\n * @param target - The name of the section to find.\n *\n * @returns a tuple of the schema and the section or a tuple of `false` and `false` if not found.\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function findSection(\n  schema: FormKitSchemaDefinition,\n  target: string\n):\n  | [false, false]\n  | [\n      FormKitSchemaNode[] | FormKitSchemaCondition | false | undefined,\n      FormKitSchemaCondition\n    ] {\n  return (\n    eachSection(\n      schema,\n      (section, sectionCondition, parent) => {\n        if (section.meta?.section === target) {\n          return [parent, sectionCondition]\n        }\n        return\n      },\n      true\n    ) ?? [false, false]\n  )\n}\n\n/**\n * Runs a callback over every section in a schema. if stopOnCallbackReturn is true\n * and the callback returns a value, the iteration will stop and return that value.\n *\n * @param schema - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode} array.\n * @param callback - A callback to run on every section.\n * @param stopOnCallbackReturn - If true, the loop will stop if the callback returns a value.\n * @param schemaParent - The parent of the current schema node.\n *\n * @returns\n *\n * @public\n */\nexport function eachSection<T>(\n  schema: FormKitSchemaDefinition,\n  callback: (\n    section: FormKitSchemaComponent | FormKitSchemaDOMNode,\n    sectionConditional: FormKitSchemaCondition,\n    sectionParent: FormKitSchemaNode[] | FormKitSchemaCondition | undefined\n  ) => T,\n  stopOnCallbackReturn = false,\n  schemaParent?: FormKitSchemaNode[] | FormKitSchemaCondition\n): T | void {\n  if (Array.isArray(schema)) {\n    for (const node of schema) {\n      const callbackReturn = eachSection(\n        node,\n        callback,\n        stopOnCallbackReturn,\n        schema\n      )\n      if (callbackReturn && stopOnCallbackReturn) {\n        return callbackReturn\n      }\n    }\n    return\n  }\n  if (isSection(schema)) {\n    const callbackReturn = callback(schema.else, schema, schemaParent)\n    if (callbackReturn && stopOnCallbackReturn) {\n      return callbackReturn\n    }\n    return eachSection(schema.else, callback, stopOnCallbackReturn, schema)\n  } else if ((isComponent(schema) || isDOM(schema)) && schema.children) {\n    return eachSection(\n      schema.children as FormKitSchemaNode,\n      callback,\n      stopOnCallbackReturn\n    )\n  } else if (isConditional(schema)) {\n    let callbackReturn: T | void = undefined\n\n    if (schema.then && typeof schema.then !== 'string') {\n      callbackReturn = eachSection(\n        schema.then,\n        callback,\n        stopOnCallbackReturn,\n        schema\n      )\n    }\n\n    if (!callbackReturn && schema.else && typeof schema.else !== 'string') {\n      callbackReturn = eachSection(\n        schema.else,\n        callback,\n        stopOnCallbackReturn,\n        schema\n      )\n    }\n\n    if (callbackReturn && stopOnCallbackReturn) {\n      return callbackReturn\n    }\n  }\n}\n\n/**\n * Check if a schema node is conditional, has an else clause, and that else\n * clause contains a section in the meta.\n * @param section - A schema node to check.\n * @public\n */\nfunction isSection(\n  section: FormKitSchemaNode\n): section is FormKitSchemaSection {\n  if (\n    isConditional(section) &&\n    typeof section.then === 'string' &&\n    section.else &&\n    typeof section.else !== 'string' &&\n    !Array.isArray(section.else) &&\n    !isConditional(section.else) &&\n    section.else.meta?.section\n  ) {\n    return true\n  }\n  return false\n}\n/**\n * Creates an input schema with all of the wrapping base schema.\n *\n * @param inputSection - Content to store in the input section key location.\n *\n * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function useSchema(\n  inputSection: FormKitSection,\n  sectionsSchema: FormKitSectionsSchema = {}\n): FormKitSchemaExtendableSection {\n  const schema = /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(/* #__PURE__ */ icon('prefix'), /* #__PURE__ */ prefix(), inputSection(), /* #__PURE__ */ suffix(), /* #__PURE__ */ icon('suffix'))\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  )\n  return (propSectionsSchema: FormKitSectionsSchema = {}) =>\n    schema(extend(sectionsSchema, propSectionsSchema) as FormKitSectionsSchema)\n}\n\n// ========================================================\n\n/**\n * Applies attributes to a given schema section by applying a higher order\n * function that merges a given set of attributes into the node.\n *\n * @param attrs - Attributes to apply to a {@link FormKitSchemaExtendableSection\n * | FormKitSchemaExtendableSection}.\n * @param section - A section to apply attributes to.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $attrs(\n  attrs: FormKitSchemaAttributes | (() => FormKitSchemaAttributes),\n  section: FormKitSchemaExtendableSection\n): FormKitSchemaExtendableSection {\n  const extendable = (extensions: FormKitSectionsSchema) => {\n    const node = section(extensions)\n    const attributes = typeof attrs === 'function' ? attrs() : attrs\n    if (!isObject(attributes)) return node\n    if (isSlotCondition(node) && isDOM(node.else)) {\n      node.else.attrs = { ...node.else.attrs, ...attributes }\n    } else if (isDOM(node)) {\n      node.attrs = { ...node.attrs, ...attributes }\n    }\n    return node\n  }\n  extendable._s = section._s\n  return extendable\n}\n\n/**\n * Applies a condition to a given schema section.\n *\n * @param condition - A schema condition to apply to a section.\n * @param then - The section that applies if the condition is true.\n * @param otherwise - (else) The section that applies if the condition is false.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $if(\n  condition: string,\n  then: FormKitSchemaExtendableSection,\n  otherwise?: FormKitSchemaExtendableSection\n): FormKitSchemaExtendableSection {\n  const extendable = (extensions: FormKitSectionsSchema) => {\n    const node = then(extensions)\n    if (\n      otherwise ||\n      (isSchemaObject(node) && 'if' in node) ||\n      isSlotCondition(node)\n    ) {\n      const conditionalNode: FormKitSchemaCondition = {\n        if: condition,\n        then: node,\n      }\n      if (otherwise) {\n        conditionalNode.else = otherwise(extensions)\n      }\n      return conditionalNode\n    } else if (isSlotCondition(node)) {\n      Object.assign(node.else, { if: condition })\n    } else if (isSchemaObject(node)) {\n      Object.assign(node, { if: condition })\n    }\n    return node\n  }\n  extendable._s = token()\n  return extendable\n}\n\n/**\n * Applies a condition to a given schema section.\n *\n * @param varName - The name of the variable that holds the current instance.\n * @param inName - The variable we are iterating over.\n * @param section - A section to repeat.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $for(\n  varName: string,\n  inName: string,\n  section: FormKitSchemaExtendableSection\n) {\n  return (extensions: FormKitSectionsSchema): FormKitSchemaNode => {\n    const node = section(extensions)\n    if (isSlotCondition(node)) {\n      Object.assign(node.else, { for: [varName, inName] })\n    } else if (isSchemaObject(node)) {\n      Object.assign(node, { for: [varName, inName] })\n    }\n    return node\n  }\n}\n\n/**\n * Extends a schema node with a given set of extensions.\n *\n * @param section - A section to apply an extension to.\n * @param extendWith - A partial schema snippet to apply to the section.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $extend(\n  section: FormKitSchemaExtendableSection,\n  extendWith: Partial<FormKitSchemaNode>\n): FormKitSchemaExtendableSection {\n  const extendable = (extensions: FormKitSectionsSchema) => {\n    const node = section({})\n    if (isSlotCondition(node)) {\n      if (Array.isArray(node.else)) return node\n      node.else = extendSchema(\n        extendSchema(node.else, extendWith),\n        section._s ? extensions[section._s] : {}\n      )\n      return node\n    }\n    return extendSchema(\n      extendSchema(node, extendWith),\n      section._s ? extensions[section._s] : {}\n    )\n  }\n  extendable._s = section._s\n  return extendable\n}\n\n/**\n * Creates a root schema section.\n *\n * @param section - A section to make a root from.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $root(\n  section: FormKitSchemaExtendableSection\n): FormKitExtendableSchemaRoot {\n  warn(800, '$root')\n  return createRoot(section)\n}\n\nexport function resetCounts() {\n  resetRadio()\n}\n\nexport * from './features'\nexport * from './sections'\n", "import { createSection } from '../createSection'\n\n/**\n * Actions section that shows the action buttons\n *\n * @public\n */\nexport const actions = createSection('actions', () => ({\n  $el: 'div',\n  if: '$actions',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Box section used for grouping options\n *\n * @public\n */\nexport const box = createSection('input', () => ({\n  $el: 'input',\n  bind: '$attrs',\n  attrs: {\n    type: '$type',\n    name: '$node.props.altName || $node.name',\n    disabled: '$option.attrs.disabled || $disabled',\n    onInput: '$handlers.toggleChecked',\n    checked: '$fns.eq($_value, $onValue)',\n    onBlur: '$handlers.blur',\n    value: '$: true',\n    id: '$id',\n    'aria-describedby': {\n      if: '$options.length',\n      then: {\n        if: '$option.help',\n        then: '$: \"help-\" + $option.attrs.id',\n        else: undefined,\n      },\n      else: {\n        if: '$help',\n        then: '$: \"help-\" + $id',\n        else: undefined,\n      },\n    },\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Option help section\n *\n * @public\n */\nexport const boxHelp = createSection('optionHelp', () => ({\n  $el: 'div',\n  if: '$option.help',\n  attrs: {\n    id: '$: \"help-\" + $option.attrs.id',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Box Inner section\n *\n * @public\n */\nexport const boxInner = createSection('inner', 'span')\n", "import { createSection } from '../createSection'\n\n/**\n * Label section for options\n *\n * @public\n */\nexport const boxLabel = createSection('label', 'span')\n", "import { createSection } from '../createSection'\n\n/**\n * Option section used to show an option\n *\n * @public\n */\nexport const boxOption = createSection('option', () => ({\n  $el: 'li',\n  for: ['option', '$options'],\n  attrs: {\n    'data-disabled': '$option.attrs.disabled || $disabled || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Options section used to wrap all option sections in a list\n *\n * @public\n */\nexport const boxOptions = createSection('options', 'ul')\n", "import { createSection } from '../createSection'\n\n/**\n * Wrapper section for options\n *\n * @public\n */\nexport const boxWrapper = createSection('wrapper', () => ({\n  $el: 'label',\n  attrs: {\n    'data-disabled': {\n      if: '$options.length',\n      then: undefined,\n      else: '$disabled || undefined',\n    },\n    'data-checked': {\n      if: '$options == undefined',\n      then: '$fns.eq($_value, $onValue) || undefined',\n      else: '$fns.isChecked($option.value) || undefined',\n    },\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Input section for a button\n *\n * @public\n */\nexport const buttonInput = createSection('input', () => ({\n  $el: 'button',\n  bind: '$attrs',\n  attrs: {\n    type: '$type',\n    disabled: '$disabled',\n    name: '$node.name',\n    id: '$id',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Default section for a button\n *\n * @public\n */\nexport const buttonLabel = createSection('default', null)\n", "import { createSection } from '../createSection'\n\n/**\n * Decorator section\n *\n * @public\n */\nexport const decorator = createSection('decorator', () => ({\n  $el: 'span',\n  attrs: {\n    'aria-hidden': 'true',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Fieldset section, used to describe help\n *\n * @public\n */\nexport const fieldset = createSection('fieldset', () => ({\n  $el: 'fieldset',\n  attrs: {\n    id: '$id',\n    'aria-describedby': {\n      if: '$help',\n      then: '$: \"help-\" + $id',\n      else: undefined,\n    },\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Input section for a file input\n *\n * @public\n */\nexport const fileInput = createSection('input', () => ({\n  $el: 'input',\n  bind: '$attrs',\n  attrs: {\n    type: 'file',\n    disabled: '$disabled',\n    name: '$node.name',\n    onChange: '$handlers.files',\n    onBlur: '$handlers.blur',\n    id: '$id',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * File item section for showing a file name\n *\n * @public\n */\nexport const fileItem = createSection('fileItem', () => ({\n  $el: 'li',\n  for: ['file', '$value'],\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * File list section to show all file names\n *\n * @public\n */\nexport const fileList = createSection('fileList', () => ({\n  $el: 'ul',\n  if: '$value.length',\n  attrs: {\n    'data-has-multiple': '$_hasMultipleFiles',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * File name section to show the file name\n *\n * @public\n */\nexport const fileName = createSection('fileName', () => ({\n  $el: 'span',\n  attrs: {\n    class: '$classes.fileName',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * File remove section to show a remove button for files\n *\n * @public\n */\nexport const fileRemove = createSection('fileRemove', () => ({\n  $el: 'button',\n  attrs: {\n    type: 'button',\n    onClick: '$handlers.resetFiles',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Form section\n *\n * @public\n */\nexport const formInput = createSection('form', () => ({\n  $el: 'form',\n  bind: '$attrs',\n  meta: {\n    autoAnimate: true,\n  },\n  attrs: {\n    id: '$id',\n    name: '$node.name',\n    onSubmit: '$handlers.submit',\n    'data-loading': '$state.loading || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * A simple fragment section\n *\n * @public\n */\nexport const fragment = createSection('wrapper', null, true)\n", "import { createSection } from '../createSection'\n\n/**\n * Help section that shows help text\n *\n * @public\n */\nexport const help = createSection('help', () => ({\n  $el: 'div',\n  if: '$help',\n  attrs: {\n    id: '$: \"help-\" + $id',\n  },\n}))\n", "import { createSection, FormKitSchemaExtendableSection } from '../createSection'\n\n/**\n * Icon section used by all icons\n *\n * @public\n */\nexport const icon = (\n  sectionKey: string,\n  el?: string\n): FormKitSchemaExtendableSection => {\n  return createSection(`${sectionKey}Icon`, () => {\n    const rawIconProp = `_raw${sectionKey\n      .charAt(0)\n      .toUpperCase()}${sectionKey.slice(1)}Icon`\n    return {\n      if: `$${sectionKey}Icon && $${rawIconProp}`,\n      $el: `${el ? el : 'span'}`,\n      attrs: {\n        class: `$classes.${sectionKey}Icon + \" \" + $classes.icon`,\n        innerHTML: `$${rawIconProp}`,\n        onClick: `$handlers.iconClick(${sectionKey})`,\n        role: `$fns.iconRole(${sectionKey})`,\n        tabindex: `$fns.iconRole(${sectionKey}) === \"button\" && \"0\" || undefined`,\n        for: {\n          if: `${el === 'label'}`,\n          then: '$id',\n        },\n      },\n    }\n  })()\n}\n", "import { createSection } from '../createSection'\n\n/**\n * Inner section\n *\n * @public\n */\nexport const inner = createSection('inner', 'div')\n", "import { createSection } from '../createSection'\n\n/**\n * Label section with label element\n *\n * @public\n */\nexport const label = createSection('label', () => ({\n  $el: 'label',\n  if: '$label',\n  attrs: {\n    for: '$id',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Legend section, used instead of label when its grouping fields.\n *\n * @public\n */\nexport const legend = createSection('legend', () => ({\n  $el: 'legend',\n  if: '$label',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Message section, shows a group of messages.\n *\n * @public\n */\nexport const message = createSection('message', () => ({\n  $el: 'li',\n  for: ['message', '$messages'],\n  attrs: {\n    key: '$message.key',\n    id: `$id + '-' + $message.key`,\n    'data-message-type': '$message.type',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Messages section where all messages will be displayed.\n *\n * @public\n */\nexport const messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$defaultMessagePlacement && $fns.length($messages)',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * No file section that shows when there is no files\n *\n * @public\n */\nexport const noFiles = createSection('noFiles', () => ({\n  $el: 'span',\n  if: '$value == null || $value.length == 0',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Option section used to show options\n *\n * @public\n */\nexport const optGroup = createSection('optGroup', () => ({\n  $el: 'optgroup',\n  bind: '$option.attrs',\n  attrs: {\n    label: '$option.group',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Option section used to show options\n *\n * @public\n */\nexport const option = createSection('option', () => ({\n  $el: 'option',\n  bind: '$option.attrs',\n  attrs: {\n    class: '$classes.option',\n    value: '$option.value',\n    selected: '$fns.isSelected($option)',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Options slot section that displays options when used with slots\n *\n * @public\n */\nexport const optionSlot = createSection('options', () => ({\n  $el: null,\n  if: '$options.length',\n  for: ['option', '$option.options || $options'],\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Outer section where most data attributes are assigned.\n *\n * @public\n */\nexport const outer = createSection('outer', () => ({\n  $el: 'div',\n  meta: {\n    autoAnimate: true,\n  },\n  attrs: {\n    key: '$id',\n    'data-family': '$family || undefined',\n    'data-type': '$type',\n    'data-multiple':\n      '$attrs.multiple || ($type != \"select\" && $options != undefined) || undefined',\n    'data-has-multiple': '$_hasMultipleFiles',\n    'data-disabled': '$: ($disabled !== \"false\" && $disabled) || undefined',\n    'data-empty': '$state.empty || undefined',\n    'data-complete': '$state.complete || undefined',\n    'data-invalid': '$state.invalid || undefined',\n    'data-errors': '$state.errors || undefined',\n    'data-submitted': '$state.submitted || undefined',\n    'data-prefix-icon': '$_rawPrefixIcon !== undefined || undefined',\n    'data-suffix-icon': '$_rawSuffixIcon !== undefined || undefined',\n    'data-prefix-icon-click': '$onPrefixIconClick !== undefined || undefined',\n    'data-suffix-icon-click': '$onSuffixIconClick !== undefined || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Prefix section\n *\n * @public\n */\nexport const prefix = createSection('prefix', null)\n", "import { createSection } from '../createSection'\n\n/**\n * Input section used by selects\n *\n * @public\n */\nexport const selectInput = createSection('input', () => ({\n  $el: 'select',\n  bind: '$attrs',\n  attrs: {\n    id: '$id',\n    'data-placeholder': '$fns.showPlaceholder($_value, $placeholder)',\n    disabled: '$disabled',\n    class: '$classes.input',\n    name: '$node.name',\n    onChange: '$handlers.onChange',\n    onInput: '$handlers.selectInput',\n    onBlur: '$handlers.blur',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Submit section that displays a submit button from a form\n *\n * @public\n */\nexport const submitInput = createSection('submit', () => ({\n  $cmp: 'FormKit',\n  bind: '$submitAttrs',\n  props: {\n    type: 'submit',\n    label: '$submitLabel',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Suffix section\n *\n * @public\n */\nexport const suffix = createSection('suffix', null)\n", "import { createSection } from '../createSection'\n\n/**\n * Input section\n *\n * @public\n */\nexport const textInput = createSection('input', () => ({\n  $el: 'input',\n  bind: '$attrs',\n  attrs: {\n    type: '$type',\n    disabled: '$disabled',\n    name: '$node.name',\n    onInput: '$handlers.DOMInput',\n    onBlur: '$handlers.blur',\n    value: '$_value',\n    id: '$id',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Input section used by textarea inputs\n *\n * @public\n */\nexport const textareaInput = createSection('input', () => ({\n  $el: 'textarea',\n  bind: '$attrs',\n  attrs: {\n    disabled: '$disabled',\n    name: '$node.name',\n    onInput: '$handlers.DOMInput',\n    onBlur: '$handlers.blur',\n    value: '$_value',\n    id: '$id',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n  children: '$initialValue',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Wrapper input section\n *\n * @public\n */\nexport const wrapper = createSection('wrapper', 'div')\n", "import type { FormKitNode } from '@formkit/core'\n\n/**\n * A simple counter to keep track of how many radios have been placed.\n */\nlet radioInstance = 0\n\nexport function resetRadio() {\n  radioInstance = 0\n}\n\n/**\n * Automatically rename any radio inputs.\n * @param node - A formkit node.\n * @returns\n *\n * @public\n */\nexport default function renamesRadios(node: FormKitNode) {\n  if (node.type === 'group' || node.type === 'list') {\n    node.plugins.add(renamesRadiosPlugin)\n  }\n}\n\nfunction renamesRadiosPlugin(node: FormKitNode) {\n  if (node.props.type === 'radio') {\n    node.addProps(['altName'])\n    node.props.altName = `${node.name}_${radioInstance++}`\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\nimport { has } from '@formkit/utils'\nimport normalizeBoxes from './normalizeBoxes'\nimport { shouldSelect, optionValue } from './options'\n\n/**\n * Event handler when an input is toggled.\n *\n * @param node - The {@link @formkit/node#FormKitNode | FormKitNode} being toggled.\n * @param e - The input event related to the toggling.\n *\n * @public\n */\nfunction toggleChecked(node: FormKitNode, e: Event) {\n  const el = e.target\n  if (el instanceof HTMLInputElement) {\n    const value = Array.isArray(node.props.options)\n      ? optionValue(node.props.options, el.value)\n      : el.value\n    if (Array.isArray(node.props.options) && node.props.options.length) {\n      if (!Array.isArray(node._value)) {\n        // There is no array value set\n        node.input([value])\n      } else if (\n        !node._value.some((existingValue) => shouldSelect(value, existingValue))\n      ) {\n        // The value is not in the current set\n        node.input([...node._value, value])\n      } else {\n        // Filter out equivalent values\n        node.input(\n          node._value.filter(\n            (existingValue) => !shouldSelect(value, existingValue)\n          )\n        )\n      }\n    } else {\n      if (el.checked) {\n        node.input(node.props.onValue)\n      } else {\n        node.input(node.props.offValue)\n      }\n    }\n  }\n}\n\n/**\n * Checks if a given option is present in the node value.\n *\n * @param node - The The {@link @formkit/node#FormKitNode | FormKitNode} being checked.\n * @param value - The value of any option.\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isChecked(node: FormKitNode, value: any) {\n  // We need to force vue’s reactivity to respond when the value is run:\n  node.context?.value\n  node.context?._value\n  if (Array.isArray(node._value)) {\n    return node._value.some((existingValue) =>\n      shouldSelect(optionValue(node.props.options, value), existingValue)\n    )\n  }\n  return false\n}\n\n/**\n * A feature that adds checkbox selection support.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function checkboxes(node: FormKitNode): void {\n  node.on('created', () => {\n    if (node.context?.handlers) {\n      node.context.handlers.toggleChecked = toggleChecked.bind(null, node)\n    }\n    if (node.context?.fns) {\n      node.context.fns.isChecked = isChecked.bind(null, node)\n    }\n    // Configure our default onValue and offValue\n    if (!has(node.props, 'onValue')) node.props.onValue = true\n    if (!has(node.props, 'offValue')) node.props.offValue = false\n  })\n\n  node.hook.prop(normalizeBoxes(node))\n}\n", "import { FormKitMiddleware, FormKitNode } from '@formkit/core'\nimport { extend, slugify } from '@formkit/utils'\n\n/**\n * A feature that normalizes box types (checkboxes, radios).\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @returns A {@link @formkit/node#FormKitMiddleware | FormKitMiddleware}.\n *\n * @public\n */\nexport default function normalizeBoxes(\n  node: FormKitNode\n): FormKitMiddleware<{ prop: string | symbol; value: any }> {\n  return function (prop, next) {\n    if (prop.prop === 'options' && Array.isArray(prop.value)) {\n      prop.value = prop.value.map((option) => {\n        if (!option.attrs?.id) {\n          return extend(option, {\n            attrs: {\n              id: `${node.props.id}-option-${slugify(String(option.value))}`,\n            },\n          })\n        }\n        return option\n      })\n      if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {\n        if (node.isCreated) {\n          node.input([], false)\n        } else {\n          node.on('created', () => {\n            if (!Array.isArray(node.value)) {\n              node.input([], false)\n            }\n          })\n        }\n      }\n    }\n    return next(prop)\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\n\n/**\n * Adds icon props definition.\n *\n * @param sectionKey - the location the icon should be loaded.\n * @param defaultIcon - the icon that should be loaded if a match is found in the user's CSS.\n *\n * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.\n *\n * @public\n */\nexport default function defaultIcon(sectionKey: string, defaultIcon: string) {\n  return (node: FormKitNode): void => {\n    if (node.props[`${sectionKey}Icon`] === undefined) {\n      node.props[`${sectionKey}Icon`] = defaultIcon.startsWith('<svg')\n        ? defaultIcon\n        : `default:${defaultIcon}`\n    }\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\nimport { undefine } from '@formkit/utils'\n\n/**\n * A feature that allows disabling children of this node.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function disables(node: FormKitNode): void {\n  node.on('created', () => {\n    // If the disabled prop belongs to this *actual* node (not inherited), then\n    // perform an `undefine` on it, if not then we'll let the prop be inherited.\n    if ('disabled' in node.props) {\n      node.props.disabled = undefine(node.props.disabled)\n      node.config.disabled = undefine(node.props.disabled)\n    }\n  })\n  node.hook.prop(({ prop, value }, next) => {\n    value = prop === 'disabled' ? undefine(value) : value\n    return next({ prop, value })\n  })\n  node.on('prop:disabled', ({ payload: value }) => {\n    node.config.disabled = undefine(value)\n  })\n}\n", "import { FormKitNode, createMessage } from '@formkit/core'\n\n/**\n * Creates a new feature that generates a localization message of type ui\n * for use on a given component.\n *\n * @param key - The key of the message.\n * @param value - The value of the message.\n *\n * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.\n *\n * @public\n */\nexport default function localize(\n  key: string,\n  value?: string\n): (node: FormKitNode) => void {\n  return (node: FormKitNode): void => {\n    node.store.set(\n      /* #__PURE__ */ createMessage({\n        key,\n        type: 'ui',\n        value: value || key,\n        meta: {\n          localize: true,\n          i18nArgs: [node],\n        },\n      })\n    )\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\nimport localize from './localize'\nimport { FormKitFileValue } from '../index'\n\ndeclare global {\n  interface Window {\n    _FormKit_File_Drop: boolean\n  }\n}\n\nconst isBrowser = typeof window !== 'undefined'\n\n/**\n * Remove the data-file-hover attribute from the target.\n *\n * @param e - Event\n *\n * @internal\n */\nfunction removeHover(e: Event) {\n  if (\n    e.target instanceof HTMLElement &&\n    e.target.hasAttribute('data-file-hover')\n  ) {\n    e.target.removeAttribute('data-file-hover')\n  }\n}\n\n/**\n * Prevent stray drag/drop events from navigating the window.\n *\n * @param e - Event\n *\n * @internal\n */\nfunction preventStrayDrop(type: string, e: Event) {\n  if (!(e.target instanceof HTMLInputElement)) {\n    e.preventDefault()\n  } else if (type === 'dragover') {\n    e.target.setAttribute('data-file-hover', 'true')\n  }\n  if (type === 'drop') {\n    removeHover(e)\n  }\n}\n\n/**\n * A feature to add file handling support to an input.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function files(node: FormKitNode): void {\n  // Localize our content:\n  localize('noFiles', 'Select file')(node)\n  localize('removeAll', 'Remove all')(node)\n  localize('remove')(node)\n  node.addProps(['_hasMultipleFiles'])\n\n  if (isBrowser) {\n    if (!window._FormKit_File_Drop) {\n      window.addEventListener(\n        'dragover',\n        preventStrayDrop.bind(null, 'dragover')\n      )\n      window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'))\n      window.addEventListener('dragleave', removeHover)\n      window._FormKit_File_Drop = true\n    }\n  }\n  node.hook.input((value, next) => next(Array.isArray(value) ? value : []))\n  node.on('input', ({ payload: value }) => {\n    node.props._hasMultipleFiles =\n      Array.isArray(value) && value.length > 1 ? true : undefined\n  })\n\n  node.on('reset', () => {\n    if (node.props.id && isBrowser) {\n      const el = document.getElementById(node.props.id)\n      if (el) (el as HTMLInputElement).value = ''\n    }\n  })\n\n  node.on('created', () => {\n    if (!Array.isArray(node.value)) node.input([], false)\n\n    if (!node.context) return\n\n    node.context.handlers.resetFiles = (e: Event) => {\n      e.preventDefault()\n      node.input([])\n      if (node.props.id && isBrowser) {\n        const el = document.getElementById(node.props.id)\n        if (el) (el as HTMLInputElement).value = ''\n        el?.focus()\n      }\n    }\n\n    node.context.handlers.files = (e: Event) => {\n      const files: FormKitFileValue = []\n      if (e.target instanceof HTMLInputElement && e.target.files) {\n        for (let i = 0; i < e.target.files.length; i++) {\n          let file\n          if ((file = e.target.files.item(i))) {\n            files.push({ name: file.name, file })\n          }\n        }\n        node.input(files)\n      }\n      if (node.context) node.context.files = files\n      // Call the original listener if there is one.\n\n      if (typeof node.props.attrs?.onChange === 'function') {\n        node.props.attrs?.onChange(e)\n      }\n    }\n  })\n}\n", "import { createMessage, FormKitNode } from '@formkit/core'\nimport { has, clone } from '@formkit/utils'\n\nconst loading = /* #__PURE__ */ createMessage({\n  key: 'loading',\n  value: true,\n  visible: false,\n})\n\n/**\n * Handle the submit event.\n *\n * @param e - The event\n *\n * @internal\n */\nasync function handleSubmit(node: FormKitNode, submitEvent: Event) {\n  const submitNonce = Math.random()\n  node.props._submitNonce = submitNonce\n  submitEvent.preventDefault()\n  await node.settled\n\n  if (node.ledger.value('validating')) {\n    // There are validation rules still pending.\n    node.store.set(loading)\n    await node.ledger.settled('validating')\n    node.store.remove('loading')\n    // If this was not the same submit event, bail out.\n    if (node.props._submitNonce !== submitNonce) return\n  }\n  // Set the submitted state on all children\n  const setSubmitted = (n: FormKitNode) =>\n    n.store.set(\n      /* #__PURE__ */ createMessage({\n        key: 'submitted',\n        value: true,\n        visible: false,\n      })\n    )\n  node.walk(setSubmitted)\n  setSubmitted(node)\n\n  node.emit('submit-raw')\n  if (typeof node.props.onSubmitRaw === 'function') {\n    node.props.onSubmitRaw(submitEvent, node)\n  }\n\n  if (node.ledger.value('blocking')) {\n    if (typeof node.props.onSubmitInvalid === 'function') {\n      node.props.onSubmitInvalid(node)\n    }\n    // There is still a blocking message in the store.\n    if (node.props.incompleteMessage !== false) {\n      setIncompleteMessage(node)\n    }\n  } else {\n    // No blocking messages\n    if (typeof node.props.onSubmit === 'function') {\n      // call onSubmit\n      const retVal = node.props.onSubmit(\n        node.hook.submit.dispatch(clone(node.value as Record<string, any>)),\n        node\n      )\n      if (retVal instanceof Promise) {\n        const autoDisable =\n          node.props.disabled === undefined &&\n          node.props.submitBehavior !== 'live'\n        if (autoDisable) node.props.disabled = true\n        node.store.set(loading)\n        await retVal\n        if (autoDisable) node.props.disabled = false\n        node.store.remove('loading')\n      }\n    } else {\n      if (submitEvent.target instanceof HTMLFormElement) {\n        submitEvent.target.submit()\n      }\n    }\n  }\n}\n\n/**\n * Set the incomplete message on a specific node.\n * @param node - The node to set the incomplete message on.\n */\nfunction setIncompleteMessage(node: FormKitNode) {\n  node.store.set(\n    /* #__PURE__ */ createMessage({\n      blocking: false,\n      key: `incomplete`,\n      meta: {\n        localize: node.props.incompleteMessage === undefined,\n        i18nArgs: [{ node }],\n        showAsMessage: true,\n      },\n      type: 'ui',\n      value: node.props.incompleteMessage || 'Form incomplete.',\n    })\n  )\n}\n\n/**\n * A feature to add a submit handler and actions section.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function form(node: FormKitNode): void {\n  node.props.isForm = true\n  node.ledger.count('validating', (m) => m.key === 'validating')\n\n  node.props.submitAttrs ??= {\n    disabled: node.props.disabled,\n  }\n\n  node.on('prop:disabled', ({ payload: disabled }) => {\n    node.props.submitAttrs = { ...node.props.submitAttrs, disabled }\n  })\n\n  node.on('created', () => {\n    if (node.context?.handlers) {\n      node.context.handlers.submit = handleSubmit.bind(null, node)\n    }\n    if (!has(node.props, 'actions')) {\n      node.props.actions = true\n    }\n  })\n  node.on('prop:incompleteMessage', () => {\n    if (node.store.incomplete) setIncompleteMessage(node)\n  })\n  node.on('settled:blocking', () => node.store.remove('incomplete'))\n}\n", "import { FormKitNode } from '@formkit/core'\n\n/**\n * A feature that applies `ignore=\"true\"` by default.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function ignore(node: FormKitNode): void {\n  if (node.props.ignore === undefined) {\n    node.props.ignore = true\n    node.parent = null\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\n\n/**\n * A feature that ensures the input has an `initialValue` prop.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function initialValue(node: FormKitNode): void {\n  node.on('created', () => {\n    if (node.context) {\n      node.context.initialValue = node.value || ''\n    }\n  })\n}\n", "import { FormKitNode } from '@formkit/core'\n\n/**\n * A feature that allows casting to numbers.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function casts(node: FormKitNode): void {\n  if (typeof node.props.number === 'undefined') return\n  const strict = ['number', 'range', 'hidden'].includes(node.props.type)\n  node.hook.input((value, next) => {\n    if (value === '') return next(undefined)\n    const numericValue =\n      node.props.number === 'integer' ? parseInt(value) : parseFloat(value)\n    if (!Number.isFinite(numericValue))\n      return strict ? next(undefined) : next(value)\n    return next(numericValue)\n  })\n}\n", "import { FormKitNode, warn } from '@formkit/core'\nimport normalizeBoxes from './normalizeBoxes'\nimport { optionValue, shouldSelect } from './options'\n\n/**\n * Sets the value of a radio button when checked.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n * @param event - Event\n *\n * @public\n */\nfunction toggleChecked(node: FormKitNode, event: Event) {\n  if (event.target instanceof HTMLInputElement) {\n    node.input(optionValue(node.props.options, event.target.value))\n  }\n}\n\n/**\n * Checks if the value being checked is the current value.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n * @param value - The value to check\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isChecked(node: FormKitNode, value: string) {\n  // We need to force vue’s reactivity to respond when the value is run:\n  node.context?.value\n  node.context?._value\n  return shouldSelect(optionValue(node.props.options, value), node._value)\n}\n\n/**\n * A feature to check if the value being checked is the current value.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function radios(node: FormKitNode): void {\n  node.on('created', () => {\n    if (!Array.isArray(node.props.options)) {\n      warn(350, {\n        node,\n        inputType: 'radio',\n      })\n    }\n    if (node.context?.handlers) {\n      node.context.handlers.toggleChecked = toggleChecked.bind(null, node)\n    }\n    if (node.context?.fns) {\n      node.context.fns.isChecked = isChecked.bind(null, node)\n    }\n  })\n  node.hook.prop(normalizeBoxes(node))\n}\n", "import {\n  FormKitOptionsItem,\n  FormKitOptionsGroupItem,\n  FormKitOptionsListWithGroups,\n} from './../props'\nimport { FormKitNode } from '@formkit/core'\nimport { undefine, eq } from '@formkit/utils'\nimport { shouldSelect, optionValue } from './options'\nimport { FormKitOptionsList, isGroupOption } from '../props'\n\n/**\n * Checks if a the given option should have the selected attribute.\n * @param node - The node being evaluated.\n * @param option - The option value to check\n * @returns\n * @public\n */\nfunction isSelected(\n  node: FormKitNode,\n  option: FormKitOptionsItem | FormKitOptionsGroupItem\n) {\n  if (isGroupOption(option)) return false\n  // Here we trick reactivity (if at play) to watch this function.\n  node.context && node.context.value\n  const optionValue = '__original' in option ? option.__original : option.value\n  return Array.isArray(node._value)\n    ? node._value.some((optionA) => shouldSelect(optionA, optionValue))\n    : (node._value === undefined ||\n        (node._value === null && !containsValue(node.props.options, null))) &&\n      option.attrs &&\n      option.attrs['data-is-placeholder']\n    ? true\n    : shouldSelect(optionValue, node._value)\n}\n\n/**\n * Checks to see if a given value is anywhere in the options list.\n */\nfunction containsValue(\n  options: FormKitOptionsListWithGroups,\n  value: unknown\n): boolean {\n  return options.some((option) => {\n    if (isGroupOption(option)) {\n      return containsValue(option.options, value)\n    } else {\n      return (\n        ('__original' in option ? option.__original : option.value) === value\n      )\n    }\n  })\n}\n\n/**\n * Defers the change event till after the next cycle.\n * @param node - The node being evaluated.\n * @param e - The change event.\n */\nasync function deferChange(node: FormKitNode, e: Event) {\n  if (typeof node.props.attrs?.onChange === 'function') {\n    await new Promise((r) => setTimeout(r, 0))\n    await node.settled\n    node.props.attrs.onChange(e)\n  }\n}\n\n/**\n * Select the correct values.\n * @param e - The input event emitted by the select.\n */\nfunction /* #__PURE__ */ selectInput(node: FormKitNode, e: Event) {\n  const target = e.target as HTMLSelectElement\n  const value = target.hasAttribute('multiple')\n    ? Array.from(target.selectedOptions).map((o) =>\n        optionValue(node.props.options, o.value)\n      )\n    : optionValue(node.props.options, target.value)\n  node.input(value)\n}\n\n/**\n * Appends a placeholder to the options list.\n * @param options - An options list\n * @param placeholder - A placeholder string to append\n * @returns\n */\nfunction applyPlaceholder(options: FormKitOptionsList, placeholder: string) {\n  if (\n    !options.some(\n      (option) => option.attrs && option.attrs['data-is-placeholder']\n    )\n  ) {\n    return [\n      {\n        label: placeholder,\n        value: '',\n        attrs: {\n          hidden: true,\n          disabled: true,\n          'data-is-placeholder': 'true',\n        },\n      },\n      ...options,\n    ]\n  }\n  return options\n}\n\n/**\n * Given an options list, find the first true value.\n * @param options - An options list (with groups)\n */\nfunction firstValue(options: FormKitOptionsListWithGroups): unknown {\n  const option = options.length > 0 ? options[0] : undefined\n  if (!option) return undefined\n  if (isGroupOption(option)) return firstValue(option.options)\n  return '__original' in option ? option.__original : option.value\n}\n\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nexport default function select(node: FormKitNode): void {\n  // Set the initial value of a multi-input\n  node.on('created', () => {\n    const isMultiple = undefine(node.props.attrs?.multiple)\n\n    if (\n      !isMultiple &&\n      node.props.placeholder &&\n      Array.isArray(node.props.options)\n    ) {\n      node.hook.prop(({ prop, value }, next) => {\n        if (prop === 'options') {\n          value = applyPlaceholder(value, node.props.placeholder)\n        }\n        return next({ prop, value })\n      })\n      node.props.options = applyPlaceholder(\n        node.props.options,\n        node.props.placeholder\n      )\n    }\n    if (isMultiple) {\n      if (node.value === undefined) {\n        node.input([], false)\n      }\n    } else if (node.context && !node.context.options) {\n      // If this input is (probably) using the default slot, we need to add a\n      // \"value\" attribute to get bound\n      node.props.attrs = Object.assign({}, node.props.attrs, {\n        value: node._value,\n      })\n      node.on('input', ({ payload }) => {\n        node.props.attrs = Object.assign({}, node.props.attrs, {\n          value: payload,\n        })\n      })\n    }\n    if (node.context?.handlers) {\n      node.context.handlers.selectInput = selectInput.bind(null, node)\n      node.context.handlers.onChange = deferChange.bind(null, node)\n    }\n    if (node.context?.fns) {\n      node.context.fns.isSelected = isSelected.bind(null, node)\n      node.context.fns.showPlaceholder = (value: unknown, placeholder) => {\n        if (!Array.isArray(node.props.options)) return false\n        const hasMatchingValue = node.props.options.some(\n          (option: FormKitOptionsItem) => {\n            if (option.attrs && 'data-is-placeholder' in option.attrs)\n              return false\n            const optionValue =\n              '__original' in option ? option.__original : option.value\n            return eq(value, optionValue)\n          }\n        )\n        return placeholder && !hasMatchingValue ? true : undefined\n      }\n    }\n  })\n\n  node.hook.input((value, next) => {\n    if (\n      !node.props.placeholder &&\n      value === undefined &&\n      Array.isArray(node.props?.options) &&\n      node.props.options.length &&\n      !undefine(node.props?.attrs?.multiple)\n    ) {\n      value = firstValue(node.props.options)\n    }\n    return next(value)\n  })\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  wrapper,\n  help,\n  messages,\n  message,\n  icon,\n  prefix,\n  suffix,\n  buttonInput,\n  buttonLabel,\n  localize,\n  ignores,\n} from '../compose'\n\n/**\n * Input definition for a button.\n * @public\n */\nexport const button: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value')),\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ buttonInput(\n        /* #__PURE__ */ icon('prefix'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ buttonLabel('$label || $ui.submit.value'),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help')\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'button',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [localize('submit'), ignores],\n  /**\n   * A key to use for memoizing the schema. This is used to prevent the schema\n   * from needing to be stringified when performing a memo lookup.\n   */\n  schemaMemoKey: 'h6st4epl3j8',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  boxInner,\n  help,\n  boxHelp,\n  messages,\n  message,\n  prefix,\n  suffix,\n  fieldset,\n  decorator,\n  box,\n  icon,\n  legend,\n  boxOption,\n  boxOptions,\n  boxWrapper,\n  boxLabel,\n  options,\n  checkboxes,\n  $if,\n  $extend,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a checkbox(ess).\n * @public\n */\nexport const checkbox: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    $if(\n      '$options == undefined',\n      /**\n       * Single checkbox structure.\n       */\n      /* #__PURE__ */ boxWrapper(\n        /* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ box(), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()),\n        $extend(/* #__PURE__ */ boxLabel('$label'), {\n          if: '$label',\n        })\n      ),\n      /**\n       * Multi checkbox structure.\n       */\n      /* #__PURE__ */ fieldset(\n        /* #__PURE__ */ legend('$label'),\n        /* #__PURE__ */ help('$help'),\n        /* #__PURE__ */ boxOptions(\n          /* #__PURE__ */ boxOption(\n            /* #__PURE__ */ boxWrapper(\n              /* #__PURE__ */ boxInner(\n                /* #__PURE__ */ prefix(),\n                $extend(/* #__PURE__ */ box(), {\n                  bind: '$option.attrs',\n                  attrs: {\n                    id: '$option.attrs.id',\n                    value: '$option.value',\n                    checked: '$fns.isChecked($option.value)',\n                  },\n                }),\n                /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')),\n                /* #__PURE__ */ suffix()\n              ),\n              $extend(/* #__PURE__ */ boxLabel('$option.label'), {\n                if: '$option.label',\n              })\n            ),\n            /* #__PURE__ */ boxHelp('$option.help')\n          )\n        )\n      )\n    ),\n    // Help text only goes under the input when it is a single.\n    $if('$options == undefined && $help', /* #__PURE__ */ help('$help')),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'box',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['options', 'onValue', 'offValue', 'optionsLoader'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [\n    options,\n    checkboxes,\n    defaultIcon('decorator', 'checkboxDecorator'),\n  ],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'qje02tb3gu8',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  prefix,\n  suffix,\n  icon,\n  fileInput,\n  fileItem,\n  fileList,\n  fileName,\n  fileRemove,\n  noFiles,\n  files,\n  $if,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a file input.\n * @public\n */\nexport const file: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix', 'label'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ fileInput(),\n        /* #__PURE__ */ fileList(\n          /* #__PURE__ */ fileItem(\n            /* #__PURE__ */ icon('fileItem'),\n            /* #__PURE__ */ fileName('$file.name'),\n            $if(\n              '$value.length === 1',\n              /* #__PURE__ */ fileRemove(\n                /* #__PURE__ */ icon('fileRemove'),\n                '$ui.remove.value + \" \" + $file.name'\n              )\n            )\n          )\n        ),\n        $if('$value.length > 1', /* #__PURE__ */ fileRemove('$ui.removeAll.value')),\n        /* #__PURE__ */ noFiles(/* #__PURE__ */ icon('noFiles'), '$ui.noFiles.value'),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'text',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [\n    files,\n    defaultIcon('fileItem', 'fileItem'),\n    defaultIcon('fileRemove', 'fileRemove'),\n    defaultIcon('noFiles', 'noFiles'),\n  ],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: '9kqc4852fv8',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  formInput,\n  messages,\n  message,\n  actions,\n  submitInput,\n  forms,\n  disablesChildren,\n} from '../compose'\n\n/**\n * Input definition for a form.\n * @public\n */\nexport const form: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ formInput(\n    '$slots.default',\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value')),\n    /* #__PURE__ */ actions(/* #__PURE__ */ submitInput())\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'group',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [\n    'actions',\n    'submit',\n    'submitLabel',\n    'submitAttrs',\n    'submitBehavior',\n    'incompleteMessage',\n  ],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [forms, disablesChildren],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: '5bg016redjo',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport { fragment, disablesChildren, renamesRadios } from '../compose'\n\n/**\n * Input definition for a group.\n * @public\n */\nexport const group: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ fragment('$slots.default'),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'group',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [disablesChildren, renamesRadios],\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport { textInput, casts } from '../compose'\n\n/**\n * Input definition for a hidden input.\n * @public\n */\nexport const hidden: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ textInput(),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [casts],\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport { fragment, disablesChildren, renamesRadios } from '../compose'\n\n/**\n * Input definition for a list.\n * @public\n */\nexport const list: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ fragment('$slots.default'),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'list',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['sync', 'dynamic'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [disablesChildren, renamesRadios],\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport { fragment } from '../compose'\n\n/**\n * Input definition for a meta input.\n * @public\n */\nexport const meta: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ fragment(),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [],\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  boxInner,\n  help,\n  boxHelp,\n  messages,\n  message,\n  prefix,\n  suffix,\n  fieldset,\n  decorator,\n  box,\n  icon,\n  legend,\n  boxOption,\n  boxOptions,\n  boxWrapper,\n  boxLabel,\n  options,\n  radios,\n  $if,\n  $extend,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a radio.\n * @public\n */\nexport const radio: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    $if(\n      '$options == undefined',\n      /**\n       * Single radio structure.\n       */\n      /* #__PURE__ */ boxWrapper(\n        /* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ box(), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()),\n        $extend(/* #__PURE__ */ boxLabel('$label'), {\n          if: '$label',\n        })\n      ),\n      /**\n       * Multi radio structure.\n       */\n      /* #__PURE__ */ fieldset(\n        /* #__PURE__ */ legend('$label'),\n        /* #__PURE__ */ help('$help'),\n        /* #__PURE__ */ boxOptions(\n          /* #__PURE__ */ boxOption(\n            /* #__PURE__ */ boxWrapper(\n              /* #__PURE__ */ boxInner(\n                /* #__PURE__ */ prefix(),\n                $extend(/* #__PURE__ */ box(), {\n                  bind: '$option.attrs',\n                  attrs: {\n                    id: '$option.attrs.id',\n                    value: '$option.value',\n                    checked: '$fns.isChecked($option.value)',\n                  },\n                }),\n                /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')),\n                /* #__PURE__ */ suffix()\n              ),\n              $extend(/* #__PURE__ */ boxLabel('$option.label'), {\n                if: '$option.label',\n              })\n            ),\n            /* #__PURE__ */ boxHelp('$option.help')\n          )\n        )\n      )\n    ),\n    // Help text only goes under the input when it is a single.\n    $if('$options == undefined && $help', /* #__PURE__ */ help('$help')),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'box',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['options', 'onValue', 'offValue', 'optionsLoader'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [options, radios, defaultIcon('decorator', 'radioDecorator')],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'qje02tb3gu8',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  prefix,\n  suffix,\n  icon,\n  selectInput,\n  option,\n  optionSlot,\n  optGroup,\n  $if,\n  options,\n  selects,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a select.\n * @public\n */\nexport const select: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ selectInput(\n          $if(\n            '$slots.default',\n            () => '$slots.default',\n            /* #__PURE__ */ optionSlot(\n              $if(\n                '$option.group',\n                /* #__PURE__ */ optGroup(/* #__PURE__ */ optionSlot(/* #__PURE__ */ option('$option.label'))),\n                /* #__PURE__ */ option('$option.label')\n              )\n            )\n          )\n        ),\n        $if('$attrs.multiple !== undefined', () => '', /* #__PURE__ */ icon('select')),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['options', 'placeholder', 'optionsLoader'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [options, selects, defaultIcon('select', 'select')],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'cb119h43krg',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  prefix,\n  suffix,\n  icon,\n  textareaInput,\n  initialValue,\n} from '../compose'\n\n/**\n * Input definition for a textarea.\n * @public\n */\nexport const textarea: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix', 'label'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ textareaInput(),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [initialValue],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'b1n0td79m9g',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  icon,\n  prefix,\n  suffix,\n  textInput,\n  casts,\n} from '../compose'\n\n/**\n * Input definition for a text.\n * @public\n */\nexport const text: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix', 'label'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ textInput(),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'text',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [casts],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'c3cc4kflsg',\n}\n", "/**\n * The official FormKit Inputs plugin. This package contains the source code for\n * all native HTML input types. Read the\n * {@link https://formkit.com/essentials/inputs | inputs documentation} for\n * usage instructions.\n *\n * @packageDocumentation\n */\n\n/**\n * Export the plugin.\n */\nexport { createLibraryPlugin } from './plugin'\n\n/**\n * Helper function for normalizing options.\n */\nexport { normalizeOptions } from './features/options'\n\n/**\n * createSection() and related utilities.\n */\nexport {\n  FormKitSchemaExtendableSection,\n  FormKitSection,\n  createSection,\n  isSchemaObject,\n  extendSchema,\n} from './createSection'\n\n/**\n * Composable logic.\n */\nexport * from './compose'\n\n/**\n * Prop types.\n */\nexport * from './props'\n\n/**\n * A single file object in FormKit’s synthetic \"FileList\".\n *\n * @public\n */\nexport interface FormKitFile {\n  name: string\n  file?: File\n}\n\n/**\n * A synthetic array-based \"FileList\".\n *\n * @public\n */\nexport type FormKitFileValue = FormKitFile[]\n\n/**\n * Export again as group.\n */\nimport { button } from './inputs/button'\nimport { button as submit } from './inputs/button'\nimport { checkbox } from './inputs/checkbox'\nimport { file } from './inputs/file'\nimport { form } from './inputs/form'\nimport { group } from './inputs/group'\nimport { hidden } from './inputs/hidden'\nimport { list } from './inputs/list'\nimport { meta } from './inputs/meta'\nimport { radio } from './inputs/radio'\nimport { select } from './inputs/select'\nimport { textarea } from './inputs/textarea'\nimport { text } from './inputs/text'\nimport { text as color } from './inputs/text'\nimport { text as date } from './inputs/text'\nimport { text as datetimeLocal } from './inputs/text'\nimport { text as email } from './inputs/text'\nimport { text as month } from './inputs/text'\nimport { text as number } from './inputs/text'\nimport { text as password } from './inputs/text'\nimport { text as search } from './inputs/text'\nimport { text as tel } from './inputs/text'\nimport { text as time } from './inputs/text'\nimport { text as url } from './inputs/text'\nimport { text as week } from './inputs/text'\nimport { text as range } from './inputs/text'\n\nexport {\n  button,\n  submit,\n  checkbox,\n  file,\n  form,\n  group,\n  hidden,\n  list,\n  meta,\n  radio,\n  select,\n  textarea,\n  text,\n  color,\n  date,\n  datetimeLocal,\n  email,\n  month,\n  number,\n  password,\n  search,\n  tel,\n  time,\n  url,\n  week,\n  range,\n}\n\nexport const inputs = {\n  button,\n  submit,\n  checkbox,\n  file,\n  form,\n  group,\n  hidden,\n  list,\n  meta,\n  radio,\n  select,\n  textarea,\n  text,\n  color,\n  date,\n  datetimeLocal,\n  email,\n  month,\n  number,\n  password,\n  search,\n  tel,\n  time,\n  url,\n  week,\n  range,\n}\n", "/**\n * This package contains the official themes for FormKit. Read the\n * {@link https://formkit.com/getting-started/installation |\n * installation documentation} for more information.\n *\n * @packageDocumentation\n */\n\nimport {\n  FORMKIT_VERSION,\n  FormKitNode,\n  FormKitClasses,\n  FormKitEvent,\n} from '@formkit/core'\n\n/**\n * A function that returns a class list string\n * @internal\n */\ntype ClassFunction = (node: FormKitNode, sectionKey: string) => string\n\n/**\n * A function that returns an icon SVG string.\n * @public\n */\nexport interface FormKitIconLoader {\n  (iconName: string): string | undefined | Promise<string | undefined>\n}\n\n/**\n * A function that returns a remote URL for retrieving an SVG icon by name.\n * @public\n */\nexport interface FormKitIconLoaderUrl {\n  (iconName: string): string | undefined\n}\n\n/**\n * A function to generate FormKit class functions from a JavaScript object.\n * @param classes - An object of input types with nested objects of sectionKeys and class lists.\n * @returns An object of sectionKeys with class functions.\n * @public\n */\nexport function generateClasses(\n  classes: Record<string, Record<string, string>>\n): Record<string, string | FormKitClasses | Record<string, boolean>> {\n  const classesBySectionKey: Record<string, Record<string, any>> = {}\n  Object.keys(classes).forEach((type) => {\n    Object.keys(classes[type]).forEach((sectionKey) => {\n      if (!classesBySectionKey[sectionKey]) {\n        classesBySectionKey[sectionKey] = {\n          [type]: classes[type][sectionKey],\n        }\n      } else {\n        classesBySectionKey[sectionKey][type] = classes[type][sectionKey]\n      }\n    })\n  })\n\n  Object.keys(classesBySectionKey).forEach((sectionKey) => {\n    const classesObject = classesBySectionKey[sectionKey]\n    classesBySectionKey[sectionKey] = function (node, sectionKey) {\n      return addClassesBySection(node, sectionKey, classesObject)\n    } as ClassFunction\n  })\n\n  return classesBySectionKey\n}\n\n/**\n * Updates a class list for a given sectionKey\n * @param node - the FormKit node being operated on\n * @param sectionKey - The section key to which the class list will be applied\n * @param classByType - Object containing mappings of class lists to section keys\n * @returns\n * @public\n */\nfunction addClassesBySection(\n  node: FormKitNode,\n  _sectionKey: string,\n  classesByType: Record<string, () => string>\n): string {\n  const type = node.props.type\n  const family = node.props.family\n  let classList = ''\n  if (classesByType.global) {\n    classList += classesByType.global + ' '\n  }\n  if (classesByType[`family:${family}`]) {\n    classList += classesByType[`family:${family}`] + ' '\n  }\n  if (classesByType[type]) {\n    classList += classesByType[type]\n  }\n  const listParts = classList.split('$reset')\n  if (listParts.length > 1) {\n    return `$reset ${listParts[listParts.length - 1].trim()}`\n  }\n  return listParts[0].trim()\n}\n\n/**\n * The document's computed CSS styles\n */\nlet documentStyles: Record<any, any> | undefined = undefined\nlet documentThemeLinkTag: HTMLElement | null = null\n\n/**\n * Stores the state of theme loading\n */\nlet themeDidLoad: (value?: unknown) => void\nlet themeHasLoaded = false\nlet themeWasRequested = false\n\nconst themeLoaded = /* #__PURE__ */ new Promise<void>((res) => {\n  themeDidLoad = () => {\n    themeHasLoaded = true\n    res()\n  }\n})\n\n/**\n * Check if we are client-side\n */\nconst isClient = typeof window !== 'undefined' && typeof fetch !== 'undefined'\ndocumentStyles = isClient\n  ? /* #__PURE__ */ getComputedStyle(document.documentElement)\n  : undefined\n\n/**\n * The FormKit icon Registry - a global record of loaded icons.\n * @public\n */\nexport const iconRegistry: Record<string, string | undefined> = {}\n\n/**\n * A collection of existing icon requests to avoid duplicate fetching\n */\nconst iconRequests: Record<string, any> = {}\n\n/**\n * Creates the theme plugin based on a given theme name.\n * @param theme - The name or id of the theme to apply.\n * @param icons - Icons you want to add to the global icon registry.\n * @param iconLoaderUrl - A function that returns a remote url for retrieving an\n * SVG icon by name.\n * @param iconLoader - A function that handles loading an icon when it is not\n * found in the registry.\n * @public\n */\nexport function createThemePlugin(\n  theme?: string,\n  icons?: Record<string, string | undefined>,\n  iconLoaderUrl?: FormKitIconLoaderUrl,\n  iconLoader?: FormKitIconLoader\n): (node: FormKitNode) => any {\n  if (icons) {\n    // add any user-provided icons to the registry\n    Object.assign(iconRegistry, icons)\n  }\n\n  // if we have a theme declared, request it\n  if (\n    isClient &&\n    !themeWasRequested &&\n    documentStyles?.getPropertyValue('--formkit-theme')\n  ) {\n    // we have the theme loaded locally\n    themeDidLoad()\n    themeWasRequested = true\n  } else if (theme && !themeWasRequested && isClient) {\n    // we have the theme name but need to request it remotely\n    loadTheme(theme)\n  } else if (!themeWasRequested && isClient) {\n    // we don't have a discoverable theme, so don't wait for it\n    themeDidLoad()\n  }\n\n  const themePlugin = function themePlugin(node: FormKitNode) {\n    // register the icon handler, and override with local prop value if it exists\n    node.addProps(['iconLoader', 'iconLoaderUrl'])\n    node.props.iconHandler = createIconHandler(\n      node.props?.iconLoader ? node.props.iconLoader : iconLoader,\n      node.props?.iconLoaderUrl ? node.props.iconLoaderUrl : iconLoaderUrl\n    )\n    loadIconPropIcons(node, node.props.iconHandler)\n\n    node.on('created', () => {\n      // set up the `-icon` click handlers\n      if (node?.context?.handlers) {\n        node.context.handlers.iconClick = (\n          sectionKey: string\n        ): ((e: MouseEvent) => void) | void => {\n          const clickHandlerProp = `on${sectionKey\n            .charAt(0)\n            .toUpperCase()}${sectionKey.slice(1)}IconClick`\n          const handlerFunction = node.props[clickHandlerProp]\n          if (handlerFunction && typeof handlerFunction === 'function') {\n            return (e: MouseEvent) => {\n              return handlerFunction(node, e)\n            }\n          }\n          return undefined\n        }\n      }\n      if (node?.context?.fns) {\n        node.context.fns.iconRole = (sectionKey: string): string | null => {\n          const clickHandlerProp = `on${sectionKey\n            .charAt(0)\n            .toUpperCase()}${sectionKey.slice(1)}IconClick`\n          return typeof node.props[clickHandlerProp] === 'function'\n            ? 'button'\n            : null\n        }\n      }\n    })\n  }\n\n  themePlugin.iconHandler = createIconHandler(iconLoader, iconLoaderUrl)\n  return themePlugin\n}\n\n/**\n * Loads a FormKit theme\n */\nfunction loadTheme(theme: string) {\n  if (!theme || !isClient || typeof getComputedStyle !== 'function') {\n    // if we're not client-side then bail\n    return\n  }\n\n  // since we're client-side, flag that we've requested the theme\n  themeWasRequested = true\n\n  documentThemeLinkTag = document.getElementById('formkit-theme')\n\n  // retrieve document styles on plugin creation when the window object exists\n\n  if (\n    theme &&\n    // if we have a window object\n    isClient &&\n    // we don't have an existing theme OR the theme being set up is different\n    ((!documentStyles?.getPropertyValue('--formkit-theme') &&\n      !documentThemeLinkTag) ||\n      (documentThemeLinkTag?.getAttribute('data-theme') &&\n        documentThemeLinkTag?.getAttribute('data-theme') !== theme))\n  ) {\n    // if for some reason we didn't overwrite the __FKV__ token during publish\n    // then use the `latest` tag for CDN fetching. (this applies to local dev as well)\n    const formkitVersion = FORMKIT_VERSION.startsWith('__')\n      ? 'latest'\n      : FORMKIT_VERSION\n    const themeUrl = `https://cdn.jsdelivr.net/npm/@formkit/themes@${formkitVersion}/dist/${theme}/theme.css`\n    const link = document.createElement('link')\n    link.type = 'text/css'\n    link.rel = 'stylesheet'\n    link.id = 'formkit-theme'\n    link.setAttribute('data-theme', theme)\n    link.onload = () => {\n      documentStyles = getComputedStyle(document.documentElement) // grab new variables from theme\n      themeDidLoad()\n    }\n    document.head.appendChild(link)\n    link.href = themeUrl\n    // if we had an existing theme being loaded, remove it.\n    if (documentThemeLinkTag) {\n      documentThemeLinkTag.remove()\n    }\n  }\n}\n\n/**\n * Returns a function responsible for loading an icon by name.\n * @param iconLoader - a function for loading an icon when it's not found in the\n * iconRegistry.\n * @param iconLoaderUrl - a function that returns a remote URL for retrieving an\n * SVG icon by name.\n * @public\n */\nexport function createIconHandler(\n  iconLoader?: FormKitIconLoader,\n  iconLoaderUrl?: FormKitIconLoaderUrl\n): FormKitIconLoader {\n  return (\n    iconName: string | boolean\n  ): string | undefined | Promise<string | undefined> => {\n    // bail if we got something that wasn't string\n    if (typeof iconName !== 'string') return\n    // if we're dealing with an inline SVG, just use it as-is\n    if (iconName.startsWith('<svg')) {\n      return iconName\n    }\n\n    // is this a default icon that should only load from a stylesheet?\n    const isDefault = iconName.startsWith('default:')\n    iconName = isDefault ? iconName.split(':')[1] : iconName\n\n    // check if we've already loaded the icon before\n    const iconWasAlreadyLoaded = iconName in iconRegistry\n\n    let loadedIcon: string | undefined | Promise<string | undefined> = undefined\n\n    if (iconWasAlreadyLoaded) {\n      return iconRegistry[iconName]\n    } else if (!iconRequests[iconName]) {\n      loadedIcon = getIconFromStylesheet(iconName)\n      loadedIcon =\n        isClient && typeof loadedIcon === 'undefined'\n          ? Promise.resolve(loadedIcon)\n          : loadedIcon\n      if (loadedIcon instanceof Promise) {\n        iconRequests[iconName] = loadedIcon\n          .then((iconValue) => {\n            if (!iconValue && typeof iconName === 'string' && !isDefault) {\n              return (loadedIcon =\n                typeof iconLoader === 'function'\n                  ? iconLoader(iconName)\n                  : getRemoteIcon(iconName, iconLoaderUrl))\n            }\n            return iconValue\n          })\n          .then((finalIcon) => {\n            if (typeof iconName === 'string') {\n              iconRegistry[isDefault ? `default:${iconName}` : iconName] =\n                finalIcon\n            }\n            return finalIcon\n          })\n      } else if (typeof loadedIcon === 'string') {\n        iconRegistry[isDefault ? `default:${iconName}` : iconName] = loadedIcon\n        return loadedIcon\n      }\n    }\n    return iconRequests[iconName]\n  }\n}\n\nfunction getIconFromStylesheet(\n  iconName: string\n): string | undefined | Promise<string | undefined> {\n  if (!isClient) return\n  if (themeHasLoaded) {\n    return loadStylesheetIcon(iconName)\n  } else {\n    return themeLoaded.then(() => {\n      return loadStylesheetIcon(iconName)\n    })\n  }\n}\n\nfunction loadStylesheetIcon(iconName: string) {\n  const cssVarIcon = documentStyles?.getPropertyValue(`--fk-icon-${iconName}`)\n  if (cssVarIcon) {\n    // if we have a matching icon in the CSS properties, then decode it\n    const icon: string = atob(cssVarIcon)\n    if (icon.startsWith('<svg')) {\n      iconRegistry[iconName] = icon\n      return icon\n    }\n  }\n  return undefined\n}\n\n/**\n * Attempts to fetch a remote icon from the FormKit CDN\n * @param iconName - The string name of the icon\n * @public\n */\nfunction getRemoteIcon(\n  iconName: string,\n  iconLoaderUrl?: FormKitIconLoaderUrl\n): Promise<string | undefined> | undefined {\n  const formkitVersion = FORMKIT_VERSION.startsWith('__')\n    ? 'latest'\n    : FORMKIT_VERSION\n  const fetchUrl =\n    typeof iconLoaderUrl === 'function'\n      ? iconLoaderUrl(iconName)\n      : `https://cdn.jsdelivr.net/npm/@formkit/icons@${formkitVersion}/dist/icons/${iconName}.svg`\n  if (!isClient) return undefined\n  return fetch(`${fetchUrl}`)\n    .then(async (r) => {\n      const icon = await r.text()\n      if (icon.startsWith('<svg')) {\n        return icon\n      }\n      return undefined\n    })\n    .catch((e) => {\n      console.error(e)\n      return undefined\n    })\n}\n\n/**\n * Loads icons for the matching `-icon` props on a given node\n */\nfunction loadIconPropIcons(\n  node: FormKitNode,\n  iconHandler: FormKitIconLoader\n): void {\n  const iconRegex = /^[a-zA-Z-]+(?:-icon|Icon)$/\n  const iconProps = Object.keys(node.props).filter((prop) => {\n    return iconRegex.test(prop)\n  })\n  iconProps.forEach((sectionKey) => {\n    return loadPropIcon(node, iconHandler, sectionKey)\n  })\n}\n\n/**\n * Loads an icon from an icon-prop declaration eg. suffix-icon=\"settings\"\n */\nfunction loadPropIcon(\n  node: FormKitNode,\n  iconHandler: FormKitIconLoader,\n  sectionKey: string\n): Promise<void> | void {\n  const iconName = node.props[sectionKey]\n  const loadedIcon = iconHandler(iconName)\n  const rawIconProp = `_raw${sectionKey\n    .charAt(0)\n    .toUpperCase()}${sectionKey.slice(1)}`\n  const clickHandlerProp = `on${sectionKey\n    .charAt(0)\n    .toUpperCase()}${sectionKey.slice(1)}Click`\n  node.addProps([rawIconProp, clickHandlerProp])\n  // listen for changes to the icon prop\n  node.on(`prop:${sectionKey}`, reloadIcon)\n  if (loadedIcon instanceof Promise) {\n    return loadedIcon.then((svg) => {\n      node.props[rawIconProp] = svg\n    })\n  } else {\n    node.props[rawIconProp] = loadedIcon\n  }\n  return\n}\n\n/**\n * reloads an icon when the prop value changes\n */\nfunction reloadIcon(event: FormKitEvent): void | Promise<void> {\n  const node = event.origin\n  const iconName = event.payload\n  const iconHandler = node?.props?.iconHandler\n  const sectionKey = event.name.split(':')[1]\n  const rawIconProp = `_raw${sectionKey\n    .charAt(0)\n    .toUpperCase()}${sectionKey.slice(1)}`\n\n  if (iconHandler && typeof iconHandler === 'function') {\n    const loadedIcon = iconHandler(iconName)\n\n    if (loadedIcon instanceof Promise) {\n      return loadedIcon.then((svg) => {\n        node.props[rawIconProp] = svg\n      })\n    } else {\n      node.props[rawIconProp] = loadedIcon\n    }\n  }\n}\n", "import {\n  warningHandler,\n  errorHandler,\n  FormKitHandlerPayload,\n  FormKitNode,\n  FormKitMiddleware,\n} from '@formkit/core'\n\n/**\n * Catalog of the error message codes in FormKit.\n * @public\n */\nconst errors: Record<\n  string | number,\n  string | ((error: FormKitHandlerPayload) => string)\n> = {\n  /**\n   * FormKit errors:\n   */\n  100: ({ data: node }: { data: FormKitNode }) =>\n    `Only groups, lists, and forms can have children (${node.name}).`,\n  101: ({ data: node }: { data: FormKitNode }) =>\n    `You cannot directly modify the store (${node.name}). See: https://formkit.com/advanced/core#message-store`,\n  102: ({\n    data: [node, property],\n  }: {\n    data: [node: FormKitNode, property: string]\n  }) => `You cannot directly assign node.${property} (${node.name})`,\n  103: ({ data: [operator] }) =>\n    `Schema expressions cannot start with an operator (${operator})`,\n  104: ({ data: [operator, expression] }) =>\n    `Schema expressions cannot end with an operator (${operator} in \"${expression}\")`,\n  105: ({ data: expression }) => `Invalid schema expression: ${expression}`,\n  106: ({ data: name }) => `Cannot submit because (${name}) is not in a form.`,\n  107: ({ data: [node, value] }: { data: [FormKitNode, unknown] }) =>\n    `Cannot set ${node.name} to non object value: ${value}`,\n  108: ({ data: [node, value] }: { data: [FormKitNode, unknown] }) =>\n    `Cannot set ${node.name} to non array value: ${value}`,\n  /**\n   * Input specific errors:\n   */\n  300: ({ data: [node] }: { data: [FormKitNode, unknown] }) =>\n    `Cannot set behavior prop to overscroll (on ${node.name} input) when options prop is a function.`,\n  /**\n   * FormKit vue errors:\n   */\n  600: ({ data: node }: { data: FormKitNode }) =>\n    `Unknown input type${\n      typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''\n    } (\"${node.name}\")`,\n  601: ({ data: node }: { data: FormKitNode }) =>\n    `Input definition${\n      typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''\n    } is missing a schema or component property (${node.name}).`,\n}\n\n/**\n * Catalog of the warning message codes in FormKit.\n * @public\n */\nconst warnings: Record<\n  string | number,\n  string | ((error: FormKitHandlerPayload) => string)\n> = {\n  /**\n   * Core warnings:\n   */\n  150: ({ data: fn }: { data: string }) =>\n    `Schema function \"${fn}()\" is not a valid function.`,\n  151: ({ data: id }: { data: string }) => `No form element with id: ${id}`,\n  152: ({ data: id }: { data: string }) => `No input element with id: ${id}`,\n  /**\n   * Input specific warnings:\n   */\n  350: ({\n    data: { node, inputType },\n  }: {\n    data: {\n      node: FormKitNode\n      inputType: string\n    }\n  }) =>\n    `Invalid options prop for ${node.name} input (${inputType}). See https://formkit.com/inputs/${inputType}`,\n  /**\n   * Vue warnings:\n   */\n  650: 'Schema \"$get()\" must use the id of an input to access.',\n  651: ({ data: id }: { data: string }) =>\n    `Cannot setErrors() on \"${id}\" because no such id exists.`,\n  652: ({ data: id }: { data: string }) =>\n    `Cannot clearErrors() on \"${id}\" because no such id exists.`,\n  /**\n   * Deprecation warnings:\n   */\n  800: ({ data: name }: { data: string }) => `${name} is deprecated.`,\n}\n\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeErrors: FormKitMiddleware<FormKitHandlerPayload> = (\n  error: FormKitHandlerPayload,\n  next\n) => {\n  if (error.code in errors) {\n    const err = errors[error.code]\n    error.message = typeof err === 'function' ? err(error) : err\n  }\n  return next(error)\n}\n\nlet registered = false\n\n/**\n * Register the dev handler (idempotent).\n *\n * @public\n */\nfunction register() {\n  if (!registered) {\n    errorHandler(decodeErrors)\n    warningHandler(decodeWarnings)\n    registered = true\n  }\n}\n\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeWarnings: FormKitMiddleware<FormKitHandlerPayload> = (\n  warning: FormKitHandlerPayload,\n  next\n) => {\n  if (warning.code in warnings) {\n    const warn = warnings[warning.code]\n    warning.message = typeof warn === 'function' ? warn(warning) : warn\n  }\n  return next(warning)\n}\n\n// Some bundlers need to see an export:\nexport { errors, warnings, register }\n", "import {\n  reactive,\n  computed,\n  ref,\n  watch,\n  markRaw,\n  triggerRef,\n  nextTick,\n  isRef,\n  isReactive,\n} from 'vue'\nimport {\n  FormKitPlugin,\n  FormKitFrameworkContext,\n  FormKitMessage,\n  createClasses,\n  createMessage,\n  generateClassList,\n  FormKitTypeDefinition,\n} from '@formkit/core'\nimport {\n  eq,\n  has,\n  camel,\n  empty,\n  undefine,\n  cloneAny,\n  shallowClone,\n} from '@formkit/utils'\nimport { createObserver } from '@formkit/observer'\nimport { FormKitPseudoProps } from '@formkit/core'\n\n/**\n * A plugin that creates Vue-specific context object on each given node.\n *\n * @param node - FormKitNode to create the context on.\n *\n * @public\n */\nconst vueBindings: FormKitPlugin = function vueBindings(node) {\n  /**\n   * Start a validity counter on all blocking messages.\n   */\n  node.ledger.count('blocking', (m) => m.blocking)\n  const isValid = ref<boolean>(!node.ledger.value('blocking'))\n  /**\n   * Start an error message counter.\n   */\n  node.ledger.count('errors', (m) => m.type === 'error')\n  const hasErrors = ref<boolean>(!!node.ledger.value('errors'))\n\n  /**\n   * Keep track of the first time a Vue tick cycle has passed.\n   */\n  let hasTicked = false\n  nextTick(() => {\n    hasTicked = true\n  })\n\n  /**\n   * All messages with the visibility state set to true.\n   */\n  const availableMessages = reactive<Record<string, FormKitMessage>>(\n    node.store.reduce((store, message) => {\n      if (message.visible) {\n        store[message.key] = message\n      }\n      return store\n    }, {} as Record<string, FormKitMessage>)\n  )\n  /**\n   * A flag that determines when validation messages should be displayed.\n   */\n  const validationVisibility = ref<string>(\n    node.props.validationVisibility ||\n      (node.props.type === 'checkbox' ? 'dirty' : 'blur')\n  )\n  node.on('prop:validationVisibility', ({ payload }) => {\n    validationVisibility.value = payload\n  })\n\n  /**\n   * Keep track of if this input has ever shown validation errors.\n   */\n  const hasShownErrors = ref(validationVisibility.value === 'live')\n\n  /**\n   * If the input is required or not, this is the only validation rule that\n   * needs to be explicitly called out since it powers the aria-required attr.\n   */\n  const isRequired = ref<boolean>(false)\n  const checkForRequired = (parsedRules?: Array<{ name: string }>) => {\n    isRequired.value = (parsedRules ?? []).some(\n      (rule) => rule.name === 'required'\n    )\n  }\n  checkForRequired(node.props.parsedRules)\n  node.on('prop:parsedRules', ({ payload }) => checkForRequired(payload))\n\n  /**\n   * An array of unique identifiers that should only be used for iterating\n   * inside a synced list.\n   */\n  const items = ref(node.children.map((child) => child.uid))\n\n  /**\n   * The current visibility state of validation messages.\n   */\n  const validationVisible = computed<boolean>(() => {\n    if (!context.state) return false\n    if (context.state.submitted) return true\n    if (!hasShownErrors.value && !context.state.settled) {\n      return false\n    }\n    switch (validationVisibility.value) {\n      case 'live':\n        return true\n      case 'blur':\n        return context.state.blurred\n      case 'dirty':\n        return context.state.dirty\n      default:\n        return false\n    }\n  })\n\n  /**\n   * Determines if the input should be considered \"invalid\" — note that this is different than a valid input! A\n   * valid input is one where the input is not loading, not pending validation, not unsettled, and passes all\n   * validation rules. An invalid input is one whose validation rules are not explicitly not passing, and those rules\n   * are visible to the user.\n   */\n  const isInvalid = computed<boolean>(() => {\n    return context.state.failing && validationVisible.value\n  })\n\n  /**\n   * Determines if the input should be considered \"complete\".\n   */\n  const isComplete = computed<boolean>(() => {\n    return context && hasValidation.value\n      ? isValid.value && !hasErrors.value\n      : context.state.dirty && !empty(context.value)\n  })\n\n  /**\n   * If the input has validation rules or not.\n   */\n  const hasValidation = ref<boolean>(\n    Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0\n  )\n  node.on('prop:parsedRules', ({ payload: rules }) => {\n    hasValidation.value = Array.isArray(rules) && rules.length > 0\n  })\n\n  /**\n   * All messages that are currently on display to an end user. This changes\n   * based on the current message type visibility, like errorVisibility.\n   */\n  const messages = computed<Record<string, FormKitMessage>>(() => {\n    const visibleMessages: Record<string, FormKitMessage> = {}\n    for (const key in availableMessages) {\n      const message = availableMessages[key]\n      if (message.type !== 'validation' || validationVisible.value) {\n        visibleMessages[key] = message\n      }\n    }\n    return visibleMessages\n  })\n\n  /**\n   * UI Messages.\n   */\n  const ui = reactive(\n    node.store.reduce((messages, message) => {\n      if (message.type === 'ui' && message.visible)\n        messages[message.key] = message\n      return messages\n    }, {} as Record<string, FormKitMessage>)\n  )\n\n  const passing = computed<boolean>(() => !context.state.failing)\n\n  /**\n   * This is the reactive data object that is provided to all schemas and\n   * forms. It is a subset of data in the core node object.\n   */\n  const cachedClasses = reactive<Record<string, string>>({})\n  const classes = new Proxy(cachedClasses as Record<PropertyKey, string>, {\n    get(...args) {\n      if (!node) return ''\n      const [target, property] = args\n      let className: string | null = Reflect.get(...args)\n      if (!className && typeof property === 'string') {\n        if (!has(target, property) && !property.startsWith('__v')) {\n          const observedNode = createObserver(node)\n          observedNode.watch((node) => {\n            const rootClasses =\n              typeof node.config.rootClasses === 'function'\n                ? node.config.rootClasses(property, node)\n                : {}\n            const globalConfigClasses = node.config.classes\n              ? createClasses(property, node, node.config.classes[property])\n              : {}\n            const classesPropClasses = createClasses(\n              property,\n              node,\n              node.props[`_${property}Class`]\n            )\n            const sectionPropClasses = createClasses(\n              property,\n              node,\n              node.props[`${property}Class`]\n            )\n            className = generateClassList(\n              node,\n              property,\n              rootClasses,\n              globalConfigClasses,\n              classesPropClasses,\n              sectionPropClasses\n            )\n            target[property] = className ?? ''\n          })\n        }\n      }\n      return className\n    },\n  })\n\n  node.on('prop:rootClasses', () => {\n    const keys = Object.keys(cachedClasses)\n    for (const key of keys) {\n      delete cachedClasses[key]\n    }\n  })\n\n  const describedBy = computed<string | undefined>(() => {\n    if (!node) return undefined\n    const describers = []\n    if (context.help) {\n      describers.push(`help-${node.props.id}`)\n    }\n    for (const key in messages.value) {\n      describers.push(`${node.props.id}-${key}`)\n    }\n    return describers.length ? describers.join(' ') : undefined\n  })\n\n  const value = ref(node.value)\n  const _value = ref(node.value)\n\n  const context: FormKitFrameworkContext = reactive({\n    _value,\n    attrs: node.props.attrs,\n    disabled: node.props.disabled,\n    describedBy,\n    fns: {\n      length: (obj: Record<PropertyKey, any>) => Object.keys(obj).length,\n      number: (value: any) => Number(value),\n      string: (value: any) => String(value),\n      json: (value: any) => JSON.stringify(value),\n      eq,\n    },\n    handlers: {\n      blur: (e?: Event) => {\n        if (!node) return\n        node.store.set(\n          /* #__PURE__ */ createMessage({ key: 'blurred', visible: false, value: true })\n        )\n        if (typeof node.props.attrs.onBlur === 'function') {\n          node.props.attrs.onBlur(e)\n        }\n      },\n      touch: () => {\n        const doCompare = context.dirtyBehavior === 'compare'\n        if (node.store.dirty?.value && !doCompare) return\n        const isDirty = !eq(node.props._init, node._value)\n        if (!isDirty && !doCompare) return\n        node.store.set(\n          /* #__PURE__ */ createMessage({ key: 'dirty', visible: false, value: isDirty })\n        )\n      },\n      DOMInput: (e: Event) => {\n        node.input((e.target as HTMLInputElement).value)\n        node.emit('dom-input-event', e)\n      },\n    },\n    help: node.props.help,\n    id: node.props.id as string,\n    items,\n    label: node.props.label,\n    messages,\n    didMount: false,\n    node: markRaw(node),\n    options: node.props.options,\n    defaultMessagePlacement: true,\n    slots: node.props.__slots,\n    state: {\n      blurred: false,\n      complete: isComplete,\n      dirty: false,\n      empty: empty(value),\n      submitted: false,\n      settled: node.isSettled,\n      valid: isValid,\n      invalid: isInvalid,\n      errors: hasErrors,\n      rules: hasValidation,\n      validationVisible,\n      required: isRequired,\n      failing: false,\n      passing,\n    },\n    type: node.props.type,\n    family: node.props.family,\n    ui,\n    value,\n    classes,\n  })\n\n  /**\n   * Ensure the context object is properly configured after booting up.\n   */\n  node.on('created', () => {\n    if (!eq(context.value, node.value)) {\n      _value.value = node.value\n      value.value = node.value\n      triggerRef(value)\n      triggerRef(_value)\n    }\n    ;(async () => {\n      await node.settled\n      if (node) node.props._init = cloneAny(node.value)\n    })()\n  })\n\n  /**\n   * When the node mounts, set the didMount flag.\n   */\n  node.on('mounted', () => {\n    context.didMount = true\n  })\n\n  /**\n   * Sets the settled state.\n   */\n  node.on('settled', ({ payload: isSettled }) => {\n    context.state.settled = isSettled\n  })\n\n  /**\n   * Observes node.props properties explicitly and updates them in the context\n   * object.\n   * @param observe - Props to observe and register as context data.\n   */\n  function observeProps(observe: FormKitPseudoProps) {\n    const propNames = Array.isArray(observe) ? observe : Object.keys(observe)\n    propNames.forEach((prop) => {\n      prop = camel(prop)\n      if (!has(context, prop)) {\n        context[prop] = node.props[prop]\n      }\n      node.on(`prop:${prop}`, ({ payload }) => {\n        context[prop as keyof FormKitFrameworkContext] = payload\n      })\n    })\n  }\n\n  /**\n   * We use a node observer to individually observe node props.\n   */\n  const rootProps = () => {\n    const props = [\n      '__root',\n      'help',\n      'label',\n      'disabled',\n      'options',\n      'type',\n      'attrs',\n      'preserve',\n      'preserveErrors',\n      'id',\n      'dirtyBehavior',\n    ]\n    const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/\n    const matchingProps = Object.keys(node.props).filter((prop) => {\n      return iconPattern.test(prop)\n    })\n    return props.concat(matchingProps)\n  }\n  observeProps(rootProps())\n\n  /**\n   * Once the input is defined, deal with it.\n   * @param definition - Type definition.\n   */\n  function definedAs<V = unknown>(definition: FormKitTypeDefinition<V>) {\n    if (definition.props) observeProps(definition.props)\n  }\n\n  node.props.definition && definedAs(node.props.definition)\n\n  /**\n   * When new props are added to the core node as \"props\" (ie not attrs) then\n   * we automatically need to start tracking them here.\n   */\n  node.on('added-props', ({ payload }) => observeProps(payload))\n\n  /**\n   * Watch for input events from core.\n   */\n  node.on('input', ({ payload }) => {\n    if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n      _value.value = shallowClone(payload)\n    } else {\n      _value.value = payload\n      triggerRef(_value)\n    }\n  })\n\n  /**\n   * Model updates from core. This is the raw value and should emitted as a\n   * model update even if the value did not update internally. Why? Because\n   * the model that created this event may have not be the same value as our\n   * internal value.\n   *\n   * See test: \"emits a modelUpdated event even when the value results in the\n   * same value\"\n   */\n  node.on('commitRaw', ({ payload }) => {\n    if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n      value.value = _value.value = shallowClone(payload)\n    } else {\n      value.value = _value.value = payload\n      triggerRef(value)\n    }\n    node.emit('modelUpdated')\n  })\n\n  /**\n   * Watch for input commits from core.\n   */\n  node.on('commit', ({ payload }) => {\n    // The input is dirty after a value has been input by a user\n    if (\n      (!context.state.dirty || context.dirtyBehavior === 'compare') &&\n      node.isCreated &&\n      hasTicked\n    ) {\n      if (!node.store.validating?.value) {\n        context.handlers.touch()\n      } else {\n        const receipt = node.on('message-removed', ({ payload: message }) => {\n          if (message.key === 'validating') {\n            context.handlers.touch()\n            node.off(receipt)\n          }\n        })\n      }\n    }\n    if (\n      isComplete &&\n      node.type === 'input' &&\n      hasErrors.value &&\n      !undefine(node.props.preserveErrors)\n    ) {\n      node.store.filter(\n        (message) =>\n          !(message.type === 'error' && message.meta?.autoClear === true)\n      )\n    }\n    if (node.type === 'list' && node.sync) {\n      items.value = node.children.map((child) => child.uid)\n    }\n    context.state.empty = empty(payload)\n  })\n\n  /**\n   * Update the local state in response to messages.\n   * @param message - A formkit message\n   */\n  const updateState = async (message: FormKitMessage) => {\n    if (\n      message.type === 'ui' &&\n      message.visible &&\n      !message.meta.showAsMessage\n    ) {\n      ui[message.key] = message\n    } else if (message.visible) {\n      availableMessages[message.key] = message\n    } else if (message.type === 'state') {\n      context.state[message.key] = !!message.value\n    }\n  }\n\n  /**\n   * Listen to message events and modify the local message data values.\n   */\n  node.on('message-added', (e) => updateState(e.payload))\n  node.on('message-updated', (e) => updateState(e.payload))\n  node.on('message-removed', ({ payload: message }) => {\n    delete ui[message.key]\n    delete availableMessages[message.key]\n    delete context.state[message.key]\n  })\n  node.on('settled:blocking', () => {\n    isValid.value = true\n  })\n  node.on('unsettled:blocking', () => {\n    isValid.value = false\n  })\n  node.on('settled:errors', () => {\n    hasErrors.value = false\n  })\n  node.on('unsettled:errors', () => {\n    hasErrors.value = true\n  })\n\n  /**\n   * Watch the validation visible prop and set the hasShownErrors state.\n   */\n  watch(validationVisible, (value) => {\n    if (value) {\n      hasShownErrors.value = true\n    }\n  })\n\n  node.context = context\n\n  // The context is complete\n  node.emit('context', node, false)\n\n  node.on('destroyed', () => {\n    node.context = undefined\n    /* @ts-ignore */ // eslint-disable-line\n    node = null\n  })\n}\n\nexport default vueBindings\n", "import { FormKitOptions, FormKitLibrary } from '@formkit/core'\nimport { extend } from '@formkit/utils'\nimport * as defaultRules from '@formkit/rules'\nimport {\n  createValidationPlugin,\n  FormKitValidationRule,\n} from '@formkit/validation'\nimport {\n  createI18nPlugin,\n  FormKitLocale,\n  FormKitLocaleRegistry,\n  en,\n} from '@formkit/i18n'\nimport { createLibraryPlugin, inputs as defaultInputs } from '@formkit/inputs'\nimport {\n  createThemePlugin,\n  FormKitIconLoader,\n  FormKitIconLoaderUrl,\n} from '@formkit/themes'\nimport bindings from './bindings'\nimport { register as decodeErrors } from '@formkit/dev'\n\n/**\n * Configuration for plugins\n *\n * @public\n */\nexport interface PluginConfigs {\n  rules: Record<string, FormKitValidationRule>\n  locales: FormKitLocaleRegistry\n  inputs: FormKitLibrary\n  messages: Record<string, Partial<FormKitLocale>>\n  locale: string\n  theme: string\n  iconLoaderUrl: FormKitIconLoaderUrl\n  iconLoader: FormKitIconLoader\n  icons: Record<string, string | undefined>\n}\n\n/**\n * The allowed options for defaultConfig.\n *\n * @public\n */\nexport type DefaultConfigOptions = FormKitOptions &\n  Partial<PluginConfigs> &\n  Record<string, unknown>\n\n/**\n * Default configuration options. Includes all validation rules,\n * en i18n messages.\n *\n * @public\n */\nexport const defaultConfig = (\n  options: DefaultConfigOptions = {}\n): FormKitOptions => {\n  decodeErrors()\n  const {\n    rules = {},\n    locales = {},\n    inputs = {},\n    messages = {},\n    locale = undefined,\n    theme = undefined,\n    iconLoaderUrl = undefined,\n    iconLoader = undefined,\n    icons = {},\n    ...nodeOptions\n  } = options\n  /**\n   * The default configuration includes the validation plugin,\n   * with all core-available validation rules.\n   */\n  const validation = createValidationPlugin({\n    ...defaultRules,\n    ...(rules || {}),\n  })\n\n  /**\n   * Includes the i18n plugin with only the english language\n   * messages.\n   */\n  const i18n = createI18nPlugin(\n    extend({ en, ...(locales || {}) }, messages) as FormKitLocaleRegistry\n  )\n\n  /**\n   * Create the library of inputs that are generally available. This default\n   * config imports all \"native\" inputs by default, but\n   */\n  const library = createLibraryPlugin(defaultInputs, inputs)\n\n  /**\n   * Create the theme plugin for the user provided theme\n   */\n  const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader)\n\n  return extend(\n    {\n      plugins: [library, themePlugin, bindings, i18n, validation],\n      ...(!locale ? {} : { config: { locale } }),\n    },\n    nodeOptions || {},\n    true\n  ) as FormKitOptions\n}\n", "import { error, FormKitNode, FormKitSchemaDefinition } from '@formkit/core'\nimport {\n  h,\n  ref,\n  defineComponent,\n  InjectionKey,\n  ConcreteComponent,\n  VNode,\n  RendererNode,\n  RendererElement,\n  SetupContext,\n  RenderFunction,\n  VNodeProps,\n  AllowedComponentProps,\n  ComponentCustomProps,\n  markRaw,\n} from 'vue'\nimport { useInput } from './composables/useInput'\nimport { FormKitSchema } from './FormKitSchema'\nimport {\n  FormKitInputs,\n  FormKitInputSlots,\n  FormKitEvents,\n  InputType,\n  runtimeProps,\n} from '@formkit/inputs'\nimport { getCurrentInstance } from 'vue'\n\n/**\n * The type definition for the FormKit’s slots, this is not intended to be used\n * directly.\n * @public\n */\nexport type Slots<Props extends FormKitInputs<Props>> =\n  InputType<Props> extends keyof FormKitInputSlots<Props>\n    ? FormKitInputSlots<Props>[InputType<Props>]\n    : {}\n\n/**\n * The TypeScript definition for the FormKit component.\n * @public\n */\nexport type FormKitComponent = <Props extends FormKitInputs<Props>>(\n  props: Props & VNodeProps & AllowedComponentProps & ComponentCustomProps,\n  context?: Pick<FormKitSetupContext<Props>, 'attrs' | 'emit' | 'slots'>,\n  setup?: FormKitSetupContext<Props>\n) => VNode<\n  RendererNode,\n  RendererElement,\n  {\n    [key: string]: any\n  }\n> & { __ctx?: FormKitSetupContext<Props> }\n\n/**\n * Type definition for the FormKit component Vue context.\n * @public\n */\nexport interface FormKitSetupContext<Props extends FormKitInputs<Props>> {\n  props: {} & Props\n  expose(exposed: {}): void\n  attrs: any\n  slots: Slots<Props>\n  emit: FormKitEvents<Props>\n}\n\n/**\n * Flag to determine if we are running on the server.\n */\nconst isServer = typeof window === 'undefined'\n\n/**\n * The symbol that represents the formkit parent injection value.\n *\n * @public\n */\nexport const parentSymbol: InjectionKey<FormKitNode> = Symbol('FormKitParent')\n\n/**\n * The symbol that represents the formkit component callback injection value.\n * This is used by tooling to know which component \"owns\" this node — some\n * effects are linked to that component, for example, hot module reloading.\n *\n * @internal\n */\nexport const componentSymbol: InjectionKey<(node: FormKitNode) => void> =\n  Symbol('FormKitComponentCallback')\n\n/**\n * This variable is set to the node that is currently having its schema created.\n *\n * @internal\n */\nlet currentSchemaNode: FormKitNode | null = null\n\n/**\n * Returns the node that is currently having its schema created.\n *\n * @public\n */\nexport const getCurrentSchemaNode = () => currentSchemaNode\n/**\n * The actual runtime setup function for the FormKit component.\n *\n * @param props - The props passed to the component.\n * @param context - The context passed to the component.\n */\nfunction FormKit<Props extends FormKitInputs<Props>>(\n  props: Props,\n  context: SetupContext<{}, {}>\n): RenderFunction {\n  const node = useInput<Props, any>(props, context)\n  if (!node.props.definition) error(600, node)\n  if (node.props.definition.component) {\n    return () =>\n      h(\n        node.props.definition?.component as any,\n        {\n          context: node.context,\n        },\n        { ...context.slots }\n      )\n  }\n  if (true && import.meta.hot) {\n    const instance = getCurrentInstance()\n    let initPreserve: boolean | undefined\n    import.meta.hot?.on('vite:beforeUpdate', () => {\n      initPreserve = node.props.preserve\n      node.props.preserve = true\n    })\n    import.meta.hot?.on('vite:afterUpdate', () => {\n      instance?.proxy?.$forceUpdate()\n      node.props.preserve = initPreserve\n    })\n  }\n  const schema = ref<FormKitSchemaDefinition>([])\n  let memoKey: string | undefined = node.props.definition.schemaMemoKey\n  const generateSchema = () => {\n    const schemaDefinition = node.props?.definition?.schema\n    if (!schemaDefinition) error(601, node)\n    if (typeof schemaDefinition === 'function') {\n      currentSchemaNode = node\n      schema.value = schemaDefinition({ ...(props.sectionsSchema || {}) })\n      currentSchemaNode = null\n      if (\n        (memoKey && props.sectionsSchema) ||\n        ('memoKey' in schemaDefinition &&\n          typeof schemaDefinition.memoKey === 'string')\n      ) {\n        memoKey =\n          (memoKey ?? schemaDefinition?.memoKey) +\n          JSON.stringify(props.sectionsSchema)\n      }\n    } else {\n      schema.value = schemaDefinition\n    }\n  }\n  generateSchema()\n\n  // If someone emits the schema event, we re-generate the schema\n  if (!isServer) {\n    node.on('schema', () => {\n      memoKey += '♻️'\n      generateSchema()\n    })\n  }\n\n  context.emit('node', node)\n  const definitionLibrary = node.props.definition.library as\n    | Record<string, ConcreteComponent>\n    | undefined\n\n  const library = {\n    FormKit: markRaw(formkitComponent),\n    ...definitionLibrary,\n    ...(props.library ?? {}),\n  }\n\n  /**\n   * Emit the mounted event.\n   */\n  function didMount() {\n    node.emit('mounted')\n  }\n\n  // // Expose the FormKitNode to template refs.\n  context.expose({ node })\n  return () =>\n    h(\n      FormKitSchema,\n      {\n        schema: schema.value,\n        data: node.context,\n        onMounted: didMount,\n        library,\n        memoKey,\n      },\n      { ...context.slots }\n    )\n}\n\n/**\n * The root FormKit component. Use it to craft all inputs and structure of your\n * forms. For example:\n *\n * ```vue\n * <FormKit\n *  type=\"text\"\n *  label=\"Name\"\n *  help=\"Please enter your name\"\n *  validation=\"required|length:2\"\n * />\n * ```\n *\n * @public\n */\nexport const formkitComponent = /* #__PURE__ */ defineComponent(\n  FormKit as any,\n  {\n    props: runtimeProps as any,\n    inheritAttrs: false,\n  }\n) as unknown as FormKitComponent\n\n// ☝️ We need to cheat here a little bit since our runtime props and our\n// public prop interface are different (we treat some attrs as props to allow\n// for runtime \"prop\" creation).\n\nexport default formkitComponent\n", "import {\n  Component,\n  PropType,\n  RendererElement,\n  RendererNode,\n  VNode,\n  createTextVNode,\n  defineComponent,\n  h,\n  ref,\n  isRef,\n  reactive,\n  resolveComponent,\n  watchEffect,\n  watch,\n  Ref,\n  getCurrentInstance,\n  ConcreteComponent,\n  onUnmounted,\n  markRaw,\n  onMounted,\n} from 'vue'\nimport { has, isPojo } from '@formkit/utils'\nimport {\n  FormKitSchemaAttributes,\n  FormKitSchemaNode,\n  isDOM,\n  isConditional,\n  isComponent,\n  compile,\n  FormKitSchemaCondition,\n  FormKitSchemaAttributesCondition,\n  FormKitAttributeValue,\n  FormKitCompilerOutput,\n  FormKitSchemaDefinition,\n  getNode,\n  warn,\n  watchRegistry,\n  isNode,\n  sugar,\n} from '@formkit/core'\nimport { onSSRComplete } from './composables/onSSRComplete'\nimport FormKit from './FormKit'\n\n/**\n * A simple flag to tell if we are running on the server or not.\n */\nconst isServer = typeof window === 'undefined'\n\n/**\n * A library of components available to the schema (in addition to globally\n * registered ones)\n *\n * @public\n */\nexport interface FormKitComponentLibrary {\n  [index: string]: Component\n}\n\n/**\n * Defines the structure a parsed node.\n */\ntype RenderContent = [\n  condition: false | (() => boolean | number | string),\n  element: string | Component | null,\n  attrs: () => FormKitSchemaAttributes,\n  children: RenderChildren | null,\n  alternate: RenderChildren | null,\n  iterator:\n    | null\n    | [\n        getNodeValues: () =>\n          | number\n          | string\n          | boolean\n          | any[]\n          | Record<string, any>,\n        valueName: string,\n        keyName: string | null\n      ],\n  resolve: boolean\n]\n/**\n * The actual signature of a VNode in Vue.\n *\n * @public\n */\nexport type VirtualNode = VNode<\n  RendererNode,\n  RendererElement,\n  { [key: string]: any }\n>\n/**\n * The types of values that can be rendered by Vue.\n *\n * @public\n */\nexport type Renderable = null | string | number | boolean | VirtualNode\n/**\n * A list of renderable items.\n *\n * @public\n */\nexport type RenderableList =\n  | Renderable\n  | Renderable[]\n  | (Renderable | Renderable[])[]\n\n/**\n * An object of slots\n *\n * @public\n */\nexport type RenderableSlots = Record<string, RenderableSlot>\n\n/**\n * A slot function that can be rendered.\n *\n * @public\n */\nexport type RenderableSlot = (\n  data?: Record<string, any>,\n  key?: object\n) => RenderableList\n/**\n * Describes renderable children.\n */\ninterface RenderChildren {\n  (iterationData?: Record<string, unknown>): RenderableList | RenderableSlots\n  slot?: boolean\n}\n\n/**\n * The format children elements can be in.\n */\ninterface RenderNodes {\n  (iterationData?: Record<string, unknown>): Renderable | Renderable[]\n}\n\ninterface SchemaProvider {\n  (\n    providerCallback: SchemaProviderCallback,\n    instanceKey: object\n  ): RenderChildren\n}\n\ntype SchemaProviderCallback = (\n  requirements: string[],\n  hints?: Record<string, boolean>\n) => Record<string, () => any>\n\ntype ProviderRegistry = ((\n  providerCallback: SchemaProviderCallback,\n  key: object\n) => void)[]\n\n/**\n * A registry of memoized schemas (in JSON) to their respective render function\n * and provider registry.\n */\nconst memo: Record<string, [RenderChildren, ProviderRegistry]> = {}\n\n/**\n * A map of memoized keys to how many instances of that memo are currently in\n * use.\n */\nconst memoKeys: Record<string, number> = {}\n\n/**\n * This object represents the current component instance during render. It is\n * critical for linking the current instance to the data required for render.\n */\nlet instanceKey: object\n\n/**\n * A registry of scoped data produced during runtime that is keyed by the\n * instance object. For example data from: for-loop instances and slot data.\n */\n// NOTE: This is a hack to get around the fact that the TS compiler doesn't\n// understand WeakMap's allowing us to use a object as a keys, see:\n// https://github.com/microsoft/TypeScript/issues/52534\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst instanceScopes = new WeakMap<object, Record<string, any>[]>()\n\n/**\n * Indicates the a section of the schema is raw.\n */\nconst raw = '__raw__'\n\n/**\n * Is a class prop.\n */\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/\n\n/**\n * Returns a reference as a placeholder to a specific location on an object.\n * @param data - A reactive data object\n * @param token - A dot-syntax string representing the object path\n * @returns\n */\nfunction getRef(\n  token: string,\n  data: Record<string, any> | Ref<Record<string, any>>\n): Ref<unknown> {\n  const value = ref<any>(null)\n  if (token === 'get') {\n    const nodeRefs: Record<string, Ref<unknown>> = {}\n    value.value = get.bind(null, nodeRefs)\n    return value\n  }\n  const path = token.split('.')\n  watchEffect(() => {\n    value.value = getValue(\n      isRef<Record<string, any>>(data) ? data.value : data,\n      path\n    )\n  })\n  return value\n}\n\n/**\n * Returns a value inside a set of data objects.\n * @param sets - An array of objects to search through\n * @param path - A array of string paths easily produced by split()\n * @returns\n */\nfunction getValue(\n  set: (false | Record<string, any>)[] | Record<string, any>,\n  path: string[]\n): any {\n  if (Array.isArray(set)) {\n    for (const subset of set) {\n      const value = subset !== false && getValue(subset, path)\n      if (value !== undefined) return value\n    }\n    return undefined\n  }\n  let foundValue: any = undefined\n\n  let obj: unknown = set\n  for (const i in path) {\n    const key = path[i]\n    if (typeof obj !== 'object' || obj === null) {\n      foundValue = undefined\n      break\n    }\n    const currentValue: unknown = (obj as Record<string, any>)[key]\n    if (Number(i) === path.length - 1 && currentValue !== undefined) {\n      // When the value is a function, we need to bind the `this` value\n      // before providing this back to the compiler.\n      foundValue =\n        typeof currentValue === 'function'\n          ? currentValue.bind(obj)\n          : currentValue\n      break\n    }\n    obj = currentValue\n  }\n  return foundValue\n}\n\n/**\n * Get the node from the global registry\n * @param id - A dot-syntax string where the node is located.\n */\nfunction get(nodeRefs: Record<string, Ref<unknown>>, id?: string) {\n  if (typeof id !== 'string') return warn(650)\n  if (!(id in nodeRefs)) nodeRefs[id] = ref<unknown>(undefined)\n  if (nodeRefs[id].value === undefined) {\n    nodeRefs[id].value = null\n    const root = getNode(id)\n    if (root) nodeRefs[id].value = root.context\n    watchRegistry(id, ({ payload: node }) => {\n      nodeRefs[id].value = isNode(node) ? node.context : node\n    })\n  }\n  return nodeRefs[id].value\n}\n\n/**\n *\n * @param library - A library of concrete components to use\n * @param schema -\n * @returns\n */\nfunction parseSchema(\n  library: FormKitComponentLibrary,\n  schema: FormKitSchemaNode | FormKitSchemaNode[],\n  memoKey?: string\n): SchemaProvider {\n  /**\n   * Given an if/then/else schema node, pre-compile the node and return the\n   * artifacts for the render function.\n   * @param data - The schema context object\n   * @param library - The available components\n   * @param node - The node to parse\n   */\n  function parseCondition(\n    library: FormKitComponentLibrary,\n    node: FormKitSchemaCondition\n  ): [RenderContent[0], RenderContent[3], RenderContent[4]] {\n    const condition = provider(compile(node.if), { if: true })\n    const children = createElements(library, node.then)\n    const alternate = node.else ? createElements(library, node.else) : null\n    return [condition, children, alternate]\n  }\n\n  /**\n   * Parses a conditional if/then/else attribute statement.\n   * @param data - The data object\n   * @param attr - The attribute\n   * @param _default - The default value\n   * @returns\n   */\n  function parseConditionAttr(\n    attr: FormKitSchemaAttributesCondition,\n    _default: FormKitAttributeValue\n  ): () => FormKitAttributeValue | FormKitSchemaAttributes {\n    const condition = provider(compile(attr.if))\n    let b: () => FormKitAttributeValue = () => _default\n    let a: () => FormKitAttributeValue = () => _default\n\n    if (typeof attr.then === 'object') {\n      a = parseAttrs(attr.then, undefined)\n    } else if (typeof attr.then === 'string' && attr.then?.startsWith('$')) {\n      a = provider(compile(attr.then))\n    } else {\n      a = () => attr.then\n    }\n\n    if (has(attr, 'else')) {\n      if (typeof attr.else === 'object') {\n        b = parseAttrs(attr.else)\n      } else if (typeof attr.else === 'string' && attr.else?.startsWith('$')) {\n        b = provider(compile(attr.else))\n      } else {\n        b = () => attr.else\n      }\n    }\n    return () => (condition() ? a() : b())\n  }\n\n  /**\n   * Parse attributes for dynamic content.\n   * @param attrs - Object of attributes\n   * @returns\n   */\n  function parseAttrs(\n    unparsedAttrs?: FormKitSchemaAttributes | FormKitSchemaAttributesCondition,\n    bindExp?: string,\n    _default = {}\n  ): () => FormKitSchemaAttributes {\n    const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}))\n    const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({})\n    const staticAttrs: FormKitSchemaAttributes = {}\n    const setters: Array<(obj: Record<string, any>) => void> = [\n      (attrs) => {\n        const bound: Record<string, any> = boundAttrs()\n        for (const attr in bound) {\n          if (!explicitAttrs.has(attr)) {\n            attrs[attr] = bound[attr]\n          }\n        }\n      },\n    ]\n    if (unparsedAttrs) {\n      if (isConditional(unparsedAttrs)) {\n        // This is a root conditional object that must produce an object of\n        // attributes.\n        const condition = parseConditionAttr(\n          unparsedAttrs,\n          _default\n        ) as () => FormKitSchemaAttributes\n        return condition\n      }\n      // Some attributes are explicitly bound, we need to parse those ones\n      // using the compiler and create a dynamic \"setter\".\n      for (let attr in unparsedAttrs) {\n        const value = unparsedAttrs[attr]\n        let getValue: () => any\n        const isStr = typeof value === 'string'\n\n        if (attr.startsWith(raw)) {\n          // attributes prefixed with __raw__ should not be parsed\n          attr = attr.substring(7)\n          getValue = () => value\n        } else if (\n          isStr &&\n          value.startsWith('$') &&\n          value.length > 1 &&\n          !(value.startsWith('$reset') && isClassProp.test(attr))\n        ) {\n          // Most attribute values starting with $ should be compiled\n          // -class attributes starting with `$reset` should not be compiled\n          getValue = provider(compile(value))\n        } else if (typeof value === 'object' && isConditional(value)) {\n          // Conditional attrs require further processing\n          getValue = parseConditionAttr(value, undefined)\n        } else if (typeof value === 'object' && isPojo(value)) {\n          // Sub-parse pojos\n          getValue = parseAttrs(value)\n        } else {\n          // In all other cases, the value is static\n          getValue = () => value\n          staticAttrs[attr] = value\n        }\n        setters.push((attrs) => {\n          attrs[attr] = getValue()\n        })\n      }\n    }\n    return () => {\n      const attrs = Array.isArray(unparsedAttrs) ? [] : {}\n      setters.forEach((setter) => setter(attrs))\n      return attrs\n    }\n  }\n\n  /**\n   * Given a single schema node, parse it and extract the value.\n   * @param data - A state object provided to each node\n   * @param node - The schema node being parsed\n   * @returns\n   */\n  function parseNode(\n    library: FormKitComponentLibrary,\n    _node: FormKitSchemaNode\n  ): RenderContent {\n    let element: RenderContent[1] = null\n    let attrs: () => FormKitSchemaAttributes = () => null\n    let condition: false | (() => boolean | number | string) = false\n    let children: RenderContent[3] = null\n    let alternate: RenderContent[4] = null\n    let iterator: RenderContent[5] = null\n    let resolve = false\n    const node = sugar(_node)\n    if (isDOM(node)) {\n      // This is an actual HTML DOM element\n      element = node.$el\n      attrs =\n        node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null\n    } else if (isComponent(node)) {\n      // This is a Vue Component\n      if (typeof node.$cmp === 'string') {\n        if (has(library, node.$cmp)) {\n          element = library[node.$cmp]\n        } else {\n          element = node.$cmp\n          resolve = true\n        }\n      } else {\n        // in this case it must be an actual component\n        element = node.$cmp\n      }\n      attrs = parseAttrs(node.props, node.bind)\n    } else if (isConditional(node)) {\n      // This is an if/then schema statement\n      ;[condition, children, alternate] = parseCondition(library, node)\n    }\n\n    // This is the same as a \"v-if\" statement — not an if/else statement\n    if (!isConditional(node) && 'if' in node) {\n      condition = provider(compile(node.if as string))\n    } else if (!isConditional(node) && element === null) {\n      // In this odd case our element is actually a partial and\n      // we only want to render the children.\n      condition = () => true\n    }\n\n    // Compile children down to a function\n    if ('children' in node && node.children) {\n      if (typeof node.children === 'string') {\n        // We are dealing with a raw string value\n        if (node.children.startsWith('$slots.')) {\n          // this is a lone text node, turn it into a slot\n          element = element === 'text' ? 'slot' : element\n          children = provider(compile(node.children))\n        } else if (node.children.startsWith('$') && node.children.length > 1) {\n          const value = provider(compile(node.children))\n          children = () => String(value())\n        } else {\n          children = () => String(node.children)\n        }\n      } else if (Array.isArray(node.children)) {\n        // We are dealing with node sub-children\n        children = createElements(library, node.children)\n      } else {\n        // This is a conditional if/else clause\n        const [childCondition, c, a] = parseCondition(library, node.children)\n        children = (iterationData?: Record<string, unknown>) =>\n          childCondition && childCondition()\n            ? c && c(iterationData)\n            : a && a(iterationData)\n      }\n    }\n\n    if (isComponent(node)) {\n      if (children) {\n        // Children of components need to be provided as an object of slots\n        // so we provide an object with the default slot provided as children.\n        // We also create a new scope for this default slot, and then on each\n        // render pass the scoped slot props to the scope.\n        const produceChildren = children\n        children = (iterationData?: Record<string, unknown>) => {\n          return {\n            default(\n              slotData?: Record<string, any>,\n              key?: object\n            ): RenderableList {\n              // We need to switch the current instance key back to the one that\n              // originally called this component's render function.\n              const currentKey = instanceKey\n              if (key) instanceKey = key\n              if (slotData) instanceScopes.get(instanceKey)?.unshift(slotData)\n              if (iterationData)\n                instanceScopes.get(instanceKey)?.unshift(iterationData)\n              const c = produceChildren(iterationData)\n              // Ensure our instance key never changed during runtime\n              if (slotData) instanceScopes.get(instanceKey)?.shift()\n              if (iterationData) instanceScopes.get(instanceKey)?.shift()\n              instanceKey = currentKey\n              return c as RenderableList\n            },\n          }\n        }\n        children.slot = true\n      } else {\n        // If we dont have any children, we still need to provide an object\n        // instead of an empty array (which raises a warning in vue)\n        children = () => ({})\n      }\n    }\n\n    // Compile the for loop down\n    if ('for' in node && node.for) {\n      const values = node.for.length === 3 ? node.for[2] : node.for[1]\n      const getValues =\n        typeof values === 'string' && values.startsWith('$')\n          ? provider(compile(values))\n          : () => values\n      iterator = [\n        getValues,\n        node.for[0],\n        node.for.length === 3 ? String(node.for[1]) : null,\n      ]\n    }\n    return [condition, element, attrs, children, alternate, iterator, resolve]\n  }\n\n  /**\n   * Given a particular function that produces children, ensure that the second\n   * argument of all these slots is the original instance key being used to\n   * render the slots.\n   * @param children - The children() function that will produce slots\n   */\n  function createSlots(\n    children: RenderChildren,\n    iterationData?: Record<string, unknown>\n  ): RenderableSlots | null {\n    const slots = children(iterationData) as RenderableSlots\n    const currentKey = instanceKey\n    return Object.keys(slots).reduce((allSlots, slotName) => {\n      const slotFn = slots && slots[slotName]\n      allSlots[slotName] = (data?: Record<string, any>) => {\n        return (slotFn && slotFn(data, currentKey)) || null\n      }\n      return allSlots\n    }, {} as RenderableSlots)\n  }\n\n  /**\n   * Creates an element\n   * @param data - The context data available to the node\n   * @param node - The schema node to render\n   * @returns\n   */\n  function createElement(\n    library: FormKitComponentLibrary,\n    node: FormKitSchemaNode\n  ): RenderNodes {\n    // Parses the schema node into pertinent parts\n    const [condition, element, attrs, children, alternate, iterator, resolve] =\n      parseNode(library, node)\n    // This is a sub-render function (called within a render function). It must\n    // only use pre-compiled features, and be organized in the most efficient\n    // manner possible.\n    let createNodes: RenderNodes = ((\n      iterationData?: Record<string, unknown>\n    ) => {\n      if (condition && element === null && children) {\n        // Handle conditional if/then statements\n        return condition()\n          ? children(iterationData)\n          : alternate && alternate(iterationData)\n      }\n\n      if (element && (!condition || condition())) {\n        // handle text nodes\n        if (element === 'text' && children) {\n          return createTextVNode(String(children()))\n        }\n        // Handle lone slots\n        if (element === 'slot' && children) return children(iterationData)\n        // Handle resolving components\n        const el = resolve ? resolveComponent(element as string) : element\n        // If we are rendering slots as children, ensure their instanceKey is properly added\n        const slots: RenderableSlots | null = children?.slot\n          ? createSlots(children, iterationData)\n          : null\n        // Handle dom elements and components\n        return h(\n          el as ConcreteComponent,\n          attrs(),\n          (slots || (children ? children(iterationData) : [])) as Renderable[]\n        )\n      }\n\n      return typeof alternate === 'function'\n        ? alternate(iterationData)\n        : alternate\n    }) as RenderNodes\n\n    if (iterator) {\n      const repeatedNode = createNodes\n      const [getValues, valueName, keyName] = iterator\n      createNodes = (() => {\n        const _v = getValues()\n        const values = Number.isFinite(_v)\n          ? Array(Number(_v))\n              .fill(0)\n              .map((_, i) => i)\n          : _v\n        const fragment = []\n        if (typeof values !== 'object') return null\n        const instanceScope = instanceScopes.get(instanceKey) || []\n        const isArray = Array.isArray(values)\n        for (const key in values) {\n          if (isArray && key in Array.prototype) continue // Fix #299\n          const iterationData: Record<string, unknown> = Object.defineProperty(\n            {\n              ...instanceScope.reduce(\n                (\n                  previousIterationData: Record<string, undefined>,\n                  scopedData: Record<string, undefined>\n                ) => {\n                  if (previousIterationData.__idata) {\n                    return { ...previousIterationData, ...scopedData }\n                  }\n                  return scopedData\n                },\n                {} as Record<string, undefined>\n              ),\n              [valueName]: (values as Record<string, any>)[key],\n              ...(keyName !== null\n                ? { [keyName]: isArray ? Number(key) : key }\n                : {}),\n            },\n            '__idata',\n            { enumerable: false, value: true }\n          )\n          instanceScope.unshift(iterationData)\n          fragment.push(repeatedNode.bind(null, iterationData)())\n          instanceScope.shift()\n        }\n        return fragment\n      }) as RenderNodes\n    }\n    return createNodes as RenderNodes\n  }\n\n  /**\n   * Given a schema, parse it and return the resulting renderable nodes.\n   * @param data - The schema context object\n   * @param library - The available components\n   * @param node - The node to parse\n   * @returns\n   */\n  function createElements(\n    library: FormKitComponentLibrary,\n    schema: FormKitSchemaNode | FormKitSchemaNode[]\n  ): RenderChildren {\n    if (Array.isArray(schema)) {\n      const els = schema.map(createElement.bind(null, library))\n      return (iterationData?: Record<string, unknown>) =>\n        els.map((element) => element(iterationData))\n    }\n    // Single node to render\n    const element = createElement(library, schema)\n    return (iterationData?: Record<string, unknown>) => element(iterationData)\n  }\n\n  /**\n   * Data providers produced as a result of the compiler.\n   */\n  const providers: ProviderRegistry = []\n\n  /**\n   * Append the requisite compiler provider and return the compiled function.\n   * @param compiled - A compiled function\n   * @returns\n   */\n  function provider(\n    compiled: FormKitCompilerOutput,\n    hints: Record<string, boolean> = {}\n  ) {\n    const compiledFns = new WeakMap<object, FormKitCompilerOutput>()\n    providers.push((callback: SchemaProviderCallback, key: object) => {\n      compiledFns.set(\n        key,\n        compiled.provide((tokens) => callback(tokens, hints))\n      )\n    })\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return () => compiledFns.get(instanceKey)!()\n  }\n\n  /**\n   * Creates a new instance of a given schema — this either comes from a\n   * memoized copy of the parsed schema or a freshly parsed version. An object\n   * instance key, and dataProvider functions are passed in.\n   * @param providerCallback - A function that is called for each required provider\n   * @param key - a object representing the current instance\n   */\n  function createInstance(\n    providerCallback: SchemaProviderCallback,\n    key: object\n  ) {\n    memoKey ??= toMemoKey(schema)\n    const [render, compiledProviders] = has(memo, memoKey)\n      ? memo[memoKey]\n      : [createElements(library, schema), providers]\n\n    if (!isServer) {\n      memoKeys[memoKey] ??= 0\n      memoKeys[memoKey]++\n      memo[memoKey] = [render, compiledProviders]\n    }\n\n    compiledProviders.forEach((compiledProvider) => {\n      compiledProvider(providerCallback, key)\n    })\n    return () => {\n      // Set the instance key for this pass of rendering.\n      instanceKey = key\n      return render()\n    }\n  }\n  return createInstance\n}\n\n/**\n * Checks the current runtime scope for data.\n * @param token - The token to lookup in the current scope\n * @param defaultValue - The default ref value to use if no scope is found.\n */\nfunction useScope(token: string, defaultValue: any) {\n  const scopedData = instanceScopes.get(instanceKey) || []\n  let scopedValue: any = undefined\n  if (scopedData.length) {\n    scopedValue = getValue(scopedData, token.split('.'))\n  }\n  return scopedValue === undefined ? defaultValue : scopedValue\n}\n\n/**\n * Get the current scoped data and flatten it.\n */\nfunction slotData(data: Record<string, any>, key: object) {\n  return new Proxy(data, {\n    get(...args) {\n      let data: any = undefined\n      const property = args[1]\n      if (typeof property === 'string') {\n        const prevKey = instanceKey\n        instanceKey = key\n        data = useScope(property, undefined)\n        instanceKey = prevKey\n      }\n      return data !== undefined ? data : Reflect.get(...args)\n    },\n  })\n}\n\n/**\n * Provides data to a parsed schema.\n * @param provider - The SchemaProvider (output of calling parseSchema)\n * @param data - Data to fetch values from\n * @returns\n */\nfunction createRenderFn(\n  instanceCreator: SchemaProvider,\n  data: Record<string, any>,\n  instanceKey: object\n) {\n  return instanceCreator(\n    (requirements, hints: Record<string, boolean> = {}) => {\n      return requirements.reduce((tokens, token) => {\n        if (token.startsWith('slots.')) {\n          const slot = token.substring(6)\n          const hasSlot = () =>\n            data.slots &&\n            has(data.slots, slot) &&\n            typeof data.slots[slot] === 'function'\n          if (hints.if) {\n            // If statement — dont render the slot, check if it exists\n            tokens[token] = hasSlot\n          } else if (data.slots) {\n            // Render the slot with current scope data\n            const scopedData = slotData(data, instanceKey)\n            tokens[token] = () =>\n              hasSlot() ? data.slots[slot](scopedData) : null\n          }\n        } else {\n          const value = getRef(token, data)\n          tokens[token] = () => useScope(token, value.value)\n        }\n        return tokens\n      }, {} as Record<string, any>)\n    },\n    instanceKey\n  )\n}\n\n/**\n * Removes the schema from the memo and cleans up the instance scope.\n * @param schema - The schema to remove from memo.\n * @param instanceKey - The instance key to remove.\n */\nfunction clean(\n  schema: FormKitSchemaDefinition,\n  memoKey: string | undefined,\n  instanceKey: object\n) {\n  memoKey ??= toMemoKey(schema)\n  memoKeys[memoKey]--\n  if (memoKeys[memoKey] === 0) {\n    delete memoKeys[memoKey]\n    const [, providers] = memo[memoKey]\n    delete memo[memoKey]\n    providers.length = 0\n  }\n  instanceScopes.delete(instanceKey)\n}\n\n/**\n * Convert a schema to a memo key.\n * @param schema - A schema to convert to a memo key\n */\nfunction toMemoKey(schema: FormKitSchemaDefinition) {\n  return JSON.stringify(schema, (_, value) => {\n    // Technically there shouldn’t be any functions in here, but just in case\n    // we want to sniff them out and convert them to strings\n    // See: https://github.com/formkit/formkit/issues/933\n    if (typeof value === 'function') {\n      return value.toString()\n    }\n    return value\n  })\n}\n\n/**\n * The FormKitSchema vue component:\n *\n * @public\n */\nexport const FormKitSchema = /* #__PURE__ */ defineComponent({\n  name: 'FormKitSchema',\n  props: {\n    schema: {\n      type: [Array, Object] as PropType<FormKitSchemaDefinition>,\n      required: true,\n    },\n    data: {\n      type: Object as PropType<Record<string, any>>,\n      default: () => ({}),\n    },\n    library: {\n      type: Object as PropType<FormKitComponentLibrary>,\n      default: () => ({}),\n    },\n    memoKey: {\n      type: String,\n      required: false,\n    },\n  },\n  emits: ['mounted'],\n  setup(props, context) {\n    const instance = getCurrentInstance()\n    let instanceKey = {}\n    instanceScopes.set(instanceKey, [])\n    const library = { FormKit: markRaw(FormKit), ...props.library }\n    let provider = parseSchema(library, props.schema, props.memoKey)\n    let render: RenderChildren\n    let data: Record<string, any>\n    // // Re-parse the schema if it changes:\n    if (!isServer) {\n      watch(\n        () => props.schema,\n        (newSchema, oldSchema) => {\n          const oldKey = instanceKey\n          instanceKey = {}\n          instanceScopes.set(instanceKey, [])\n          provider = parseSchema(library, props.schema, props.memoKey)\n          render = createRenderFn(provider, data, instanceKey)\n          if (newSchema === oldSchema) {\n            // In this edge case, someone pushed/modified something in the schema\n            // and we've successfully re-parsed, but since the schema is not\n            // referenced in the render function it technically isnt a dependency\n            // and we need to force a re-render since we swapped out the render\n            // function completely.\n            ;(instance?.proxy?.$forceUpdate as unknown as CallableFunction)()\n          }\n          clean(props.schema, props.memoKey, oldKey)\n        },\n        { deep: true }\n      )\n    }\n\n    // // Watch the data object explicitly\n    watchEffect(() => {\n      data = Object.assign(reactive(props.data ?? {}), {\n        slots: context.slots,\n      })\n      context.slots\n      render = createRenderFn(provider, data, instanceKey)\n    })\n\n    /**\n     * Perform cleanup operations when the component is unmounted. This should\n     * remove any memory allocations that were made during the render process.\n     */\n    function cleanUp() {\n      // Perform cleanup operations\n      clean(props.schema, props.memoKey, instanceKey)\n      /* eslint-disable @typescript-eslint/no-non-null-assertion */\n      if (data) {\n        if (data.node) data.node.destroy()\n        data.slots = null!\n        data = null!\n      }\n      render = null!\n      /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    }\n\n    // When the component is mounted, emit the mounted event\n    onMounted(() => context.emit('mounted'))\n    // For browser rendering:\n    onUnmounted(cleanUp)\n    // For SSR rendering:\n    onSSRComplete(getCurrentInstance()?.appContext.app, cleanUp)\n\n    return () => (render ? render() : null)\n  },\n})\n\nexport default FormKitSchema\n", "import { App } from 'vue'\n\n/**\n * A flag indicating if this is (likely) a server context.\n */\nconst isServer = typeof window === 'undefined'\n\n/**\n * A map of Vue applications to a set of callbacks to be flushed after SSR is\n * complete.\n */\nconst ssrCompleteRegistry = new Map<App<any>, Set<CallableFunction>>()\n\n/**\n * Flush all callbacks registered with onSSRComplete for a given app.\n * @param app - The Vue application.\n * @public\n */\nexport function ssrComplete(app: App<any>) {\n  if (!isServer) return\n  const callbacks = ssrCompleteRegistry.get(app)\n  if (!callbacks) return\n  for (const callback of callbacks) {\n    callback()\n  }\n  callbacks.clear()\n  ssrCompleteRegistry.delete(app)\n}\n\n/**\n * Register a callback for when SSR is complete. No-op if not in a server\n * context.\n * @param app - The Vue application.\n * @param callback - The callback to be called after SSR is complete.\n * @public\n */\nexport function onSSRComplete(\n  app: App<any> | undefined,\n  callback: CallableFunction\n) {\n  if (!isServer || !app) return\n  if (!ssrCompleteRegistry.has(app)) ssrCompleteRegistry.set(app, new Set())\n  ssrCompleteRegistry.get(app)?.add(callback)\n}\n", "import { h, ref, watch, provide, InjectionKey, Ref } from 'vue'\nimport { defineComponent } from 'vue'\n\n/**\n * The symbol that represents the formkit’s root element injection value.\n *\n * @public\n */\nexport const rootSymbol: InjectionKey<Ref<Document | ShadowRoot | undefined>> =\n  Symbol()\n\n/**\n * The FormKitRoot wrapper component used to provide context to FormKit about\n * whether a FormKit input is booting in a Document or ShadowRoot. This is\n * generally only necessary when booting FormKit nodes in contexts that do not\n * have a document. For example, if running code like this:\n *\n * ```ts\n * document.getElementById(node.props.id)\n * ```\n *\n * does not work because the `document` is not available or is not in the same\n * scope, you can place a `<FormKitRoot>` component somewhere near the root of\n * of your shadowRoot and it will inform any FormKitNode child (at any depth)\n * that it is running in a shadow root. The \"root\" (`Document` or `ShadowRoot`)\n * will be made available to all child nodes at `node.context._root`\n *\n * @public\n */\nexport const FormKitRoot = /* #__PURE__ */ defineComponent((_p, context) => {\n  const boundary = ref<null | HTMLElement>(null)\n  const showBody = ref(false)\n  const shadowRoot = ref<Document | ShadowRoot | undefined>(undefined)\n\n  const stopWatch = watch(boundary, (el) => {\n    let parent: Node | null | undefined = el\n    let root: null | Node = null\n    while ((parent = parent?.parentNode)) {\n      root = parent\n      if (root instanceof ShadowRoot || root instanceof Document) {\n        foundRoot(root)\n        break\n      }\n    }\n    stopWatch()\n    showBody.value = true\n  })\n  provide(rootSymbol, shadowRoot)\n\n  function foundRoot(root: Document | ShadowRoot) {\n    shadowRoot.value = root\n  }\n\n  return () =>\n    showBody.value && context.slots.default\n      ? context.slots.default()\n      : h('template', { ref: boundary })\n})\n", "import { parentSymbol, componentSymbol } from '../FormKit'\nimport { rootSymbol } from '../FormKitRoot'\nimport {\n  error,\n  createNode,\n  FormKitNode,\n  FormKitOptions,\n  FormKitMessage,\n  createMessage,\n} from '@formkit/core'\nimport { FormKitRuntimeProps } from '@formkit/inputs'\nimport {\n  nodeProps,\n  except,\n  camel,\n  extend,\n  only,\n  kebab,\n  cloneAny,\n  slugify,\n  isObject,\n  token,\n  undefine,\n  oncePerTick,\n  eq,\n  shallowClone,\n} from '@formkit/utils'\nimport {\n  toRef,\n  watchEffect,\n  inject,\n  provide,\n  watch,\n  getCurrentInstance,\n  computed,\n  ref,\n  WatchStopHandle,\n  onBeforeUnmount,\n  onMounted,\n  SetupContext,\n} from 'vue'\nimport { FormKitInputs } from '@formkit/inputs'\nimport { optionsSymbol } from '../plugin'\nimport { FormKitGroupValue } from 'packages/core/src'\nimport { FormKitPseudoProps } from '@formkit/core'\n\ninterface FormKitComponentListeners {\n  onSubmit?: (payload?: FormKitGroupValue) => Promise<unknown> | unknown\n  onSubmitRaw?: (event?: Event) => unknown\n  onSubmitInvalid?: (node?: Node) => unknown\n}\n\nconst isBrowser = typeof window !== 'undefined'\n\n/**\n * Props that are extracted from the attrs object.\n * TODO: Currently local, this should probably exported to a inputs or another\n * package.\n */\nconst pseudoProps = [\n  // Boolean props\n  'ignore',\n  'disabled',\n  'preserve',\n  // String props\n  'help',\n  'label',\n  /^preserve(-e|E)rrors/,\n  /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,\n  /^[a-zA-Z-]+(?:-class|Class)$/,\n  'prefixIcon',\n  'suffixIcon',\n  /^[a-zA-Z-]+(?:-icon|Icon)$/,\n]\n\nconst boolProps = ['disabled', 'ignore', 'preserve']\n\n/**\n * Given some props, map those props to individualized props internally.\n * @param node - A formkit node\n * @param props - Some props that may include a classes object\n */\nfunction classesToNodeProps(node: FormKitNode, props: Record<string, any>) {\n  if (props.classes) {\n    Object.keys(props.classes).forEach(\n      (key: keyof (typeof props)['classes']) => {\n        if (typeof key === 'string') {\n          node.props[`_${key}Class`] = props.classes[key]\n          // We need to ensure Vue is aware that we want to actually observe the\n          // child values too, so we touch them here.\n          if (isObject(props.classes[key]) && key === 'inner')\n            Object.values(props.classes[key])\n        }\n      }\n    )\n  }\n}\n\n/**\n * Extracts known FormKit listeners.\n * @param props - Extract known FormKit listeners.\n * @returns\n */\nfunction onlyListeners(\n  props: Record<string, unknown> | null | undefined\n): FormKitComponentListeners {\n  if (!props) return {}\n  const knownListeners = ['Submit', 'SubmitRaw', 'SubmitInvalid'].reduce(\n    (listeners, listener) => {\n      const name = `on${listener}`\n      if (name in props) {\n        if (typeof props[name] === 'function') {\n          listeners[name] = props[name] as CallableFunction\n        }\n      }\n      return listeners\n    },\n    {} as Record<string, CallableFunction>\n  )\n  return knownListeners as FormKitComponentListeners\n}\n\n/**\n * A composable for creating a new FormKit node.\n *\n * @param type - The type of node (input, group, list)\n * @param attrs - The FormKit \"props\" — which is really the attrs list.\n *\n * @returns {@link @formkit/core#FormKitNode | FormKitNode}\n *\n * @public\n */\nexport function useInput<\n  Props extends FormKitInputs<Props>,\n  Context extends SetupContext<any, any>\n>(props: Props, context: Context, options: FormKitOptions = {}): FormKitNode {\n  /**\n   * The configuration options, these are provided by either the plugin or by\n   * explicit props.\n   */\n  const config = Object.assign({}, inject(optionsSymbol) || {}, options)\n\n  /**\n   * The root element — generally this is either a Document or ShadowRoot.\n   */\n  const __root = inject(rootSymbol, ref(isBrowser ? document : undefined))\n\n  /**\n   * The component symbol, this is used to register the node with the \"owner\"\n   * component.\n   */\n  const __cmpCallback = inject(componentSymbol, () => {\n    /* void */\n  })\n\n  /**\n   * The current instance.\n   */\n  const instance = getCurrentInstance()\n\n  /**\n   * Extracts the listeners.\n   */\n  const listeners = onlyListeners(instance?.vnode.props)\n\n  /**\n   * Determines if the prop is v-modeled. Credit to:\n   * {@link https://github.com/LinusBorg | Thorsten Lünborg}\n   * for coming up with this solution.\n   */\n  const isVModeled = ['modelValue', 'model-value'].some(\n    (prop) => prop in (instance?.vnode.props ?? {})\n  )\n\n  // Track if the input has mounted or not.\n  let isMounted = false\n  onMounted(() => {\n    isMounted = true\n  })\n\n  /**\n   * Determines if the object being passed as a v-model is reactive.\n   */\n  // const isReactiveVModel = isVModeled && isReactive(props.modelValue)\n\n  /**\n   * Define the initial component\n   */\n  const value: any =\n    props.modelValue !== undefined\n      ? props.modelValue\n      : cloneAny(context.attrs.value)\n\n  /**\n   * Creates the node's initial props from the context, props, and definition\n   * @returns\n   */\n  function createInitialProps(): Record<string, any> {\n    const initialProps: Record<string, any> = {\n      ...nodeProps(props),\n      ...listeners,\n      type: props.type ?? 'text',\n      __root: __root.value,\n      __slots: context.slots,\n    }\n    const attrs = except(nodeProps(context.attrs), pseudoProps)\n    if (!attrs.key) attrs.key = token()\n    initialProps.attrs = attrs\n    const propValues = only(nodeProps(context.attrs), pseudoProps)\n    for (const propName in propValues) {\n      if (boolProps.includes(propName) && propValues[propName] === '') {\n        propValues[propName] = true\n      }\n      initialProps[camel(propName)] = propValues[propName]\n    }\n    const classesProps = { props: {} }\n    classesToNodeProps(classesProps as FormKitNode, props)\n    Object.assign(initialProps, classesProps.props)\n    if (typeof initialProps.type !== 'string') {\n      initialProps.definition = initialProps.type\n      delete initialProps.type\n    }\n    return initialProps\n  }\n\n  /**\n   * Create the FormKitNode.\n   */\n  const initialProps = createInitialProps()\n\n  /**\n   * The parent node.\n   */\n  const parent = initialProps.ignore\n    ? null\n    : props.parent || inject(parentSymbol, null)\n  const node = createNode(\n    extend(\n      config || {},\n      {\n        name: props.name || undefined,\n        value,\n        parent,\n        plugins: (config.plugins || []).concat(props.plugins ?? []),\n        config: props.config || {},\n        props: initialProps,\n        index: props.index,\n        sync: !!undefine(context.attrs.sync || context.attrs.dynamic),\n      },\n      false,\n      true\n    ) as Partial<FormKitOptions>\n  ) as FormKitNode\n\n  /**\n   * Call the component callback.\n   */\n  __cmpCallback(node)\n\n  /**\n   * If no definition has been assigned at this point — we're out!\n   */\n  if (!node.props.definition) error(600, node)\n\n  /**\n   * All props that are bound \"late\" (after node creation) — are added to a set\n   * which is used to watch the context.attrs object.\n   */\n  const lateBoundProps = ref<Set<string | RegExp>>(\n    new Set(\n      Array.isArray(node.props.__propDefs)\n        ? node.props.__propDefs\n        : Object.keys(node.props.__propDefs ?? {})\n    )\n  )\n\n  /**\n   * Any additional props added at a \"later\" time should also be part of the\n   * late bound props.\n   */\n  node.on(\n    'added-props',\n    ({ payload: lateProps }: { payload: FormKitPseudoProps }) => {\n      const propNames = Array.isArray(lateProps)\n        ? lateProps\n        : Object.keys(lateProps ?? {})\n      propNames.forEach((newProp) => lateBoundProps.value.add(newProp))\n    }\n  )\n\n  /**\n   * These prop names must be assigned.\n   */\n  const pseudoPropNames = computed(() =>\n    pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n      if (typeof prop === 'string') {\n        names.push(camel(prop))\n        names.push(kebab(prop))\n      } else {\n        names.push(prop)\n      }\n      return names\n    }, [] as Array<string | RegExp>)\n  )\n\n  /* Splits Classes object into discrete props for each key */\n  watchEffect(() => classesToNodeProps(node, props))\n\n  /**\n   * The props object already has properties even if they start as \"undefined\"\n   * so we can loop over them and individual watchEffect to prevent responding\n   * inappropriately.\n   */\n  const passThrough = nodeProps(props)\n  for (const prop in passThrough) {\n    watch(\n      () => props[prop as keyof FormKitRuntimeProps<Props>],\n      () => {\n        if (props[prop as keyof FormKitRuntimeProps<Props>] !== undefined) {\n          node.props[prop] = props[prop as keyof FormKitRuntimeProps<Props>]\n        }\n      }\n    )\n  }\n\n  // Ensure the root always stays up to date.\n  watchEffect(() => {\n    node.props.__root = __root.value\n  })\n\n  /**\n   * Watch \"pseudoProp\" attributes explicitly.\n   */\n  const attributeWatchers = new Set<WatchStopHandle>()\n  const possibleProps = nodeProps(context.attrs)\n  watchEffect(() => {\n    watchAttributes(only(possibleProps, pseudoPropNames.value))\n  })\n\n  /**\n   * Defines attributes that should be used as props.\n   * @param attrProps - Attributes that should be used as props instead\n   */\n  function watchAttributes(attrProps: Record<string, any>) {\n    attributeWatchers.forEach((stop) => {\n      stop()\n      attributeWatchers.delete(stop)\n    })\n    for (const prop in attrProps) {\n      const camelName = camel(prop)\n      attributeWatchers.add(\n        watch(\n          () => context.attrs[prop],\n          () => {\n            node.props[camelName] = context.attrs[prop]\n          }\n        )\n      )\n    }\n  }\n\n  /**\n   * Watch and dynamically set attribute values, those values that are not\n   * props and are not pseudoProps\n   */\n  watchEffect(() => {\n    const attrs = except(nodeProps(context.attrs), pseudoPropNames.value)\n    // An explicit exception to ensure naked \"multiple\" attributes appear on the\n    // outer wrapper as data-multiple=\"true\"\n    if ('multiple' in attrs) attrs.multiple = undefine(attrs.multiple)\n    if (typeof attrs.onBlur === 'function') {\n      attrs.onBlur = oncePerTick(attrs.onBlur)\n    }\n    node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs)\n  })\n\n  /**\n   * Add any/all \"prop\" errors to the store.\n   */\n  watchEffect(() => {\n    const messages = (props.errors ?? []).map((error) =>\n      /* #__PURE__ */ createMessage({\n        key: slugify(error),\n        type: 'error',\n        value: error,\n        meta: { source: 'prop' },\n      })\n    )\n    node.store.apply(\n      messages,\n      (message) => message.type === 'error' && message.meta.source === 'prop'\n    )\n  })\n\n  /**\n   * Add input errors.\n   */\n  if (node.type !== 'input') {\n    const sourceKey = `${node.name}-prop`\n    watchEffect(() => {\n      const inputErrors = props.inputErrors ?? {}\n      const keys = Object.keys(inputErrors)\n      if (!keys.length) node.clearErrors(true, sourceKey)\n      const messages = keys.reduce((messages, key) => {\n        let value = inputErrors[key]\n        if (typeof value === 'string') value = [value]\n        if (Array.isArray(value)) {\n          messages[key] = value.map((error) =>\n            /* #__PURE__ */ createMessage({\n              key: error,\n              type: 'error',\n              value: error,\n              meta: { source: sourceKey },\n            })\n          )\n        }\n        return messages\n      }, {} as Record<string, FormKitMessage[]>)\n      node.store.apply(\n        messages,\n        (message) =>\n          message.type === 'error' && message.meta.source === sourceKey\n      )\n    })\n  }\n\n  /**\n   * Watch the config prop for any changes.\n   */\n  watchEffect(() => Object.assign(node.config, props.config))\n\n  /**\n   * Produce another parent object.\n   */\n  if (node.type !== 'input') {\n    provide(parentSymbol, node)\n  }\n\n  // let inputTimeout: number | undefined\n\n  let clonedValueBeforeVmodel: unknown = undefined\n  /**\n   * Explicitly watch the input value, and emit changes (lazy)\n   */\n  node.on('modelUpdated', () => {\n    // Emit the values after commit\n    context.emit('inputRaw', node.context?.value, node)\n    if (isMounted) {\n      context.emit('input', node.context?.value, node)\n    }\n    if (isVModeled && node.context) {\n      clonedValueBeforeVmodel = cloneAny(node.value)\n      context.emit('update:modelValue', shallowClone(node.value))\n    }\n  })\n\n  /**\n   * Enabled support for v-model, using this for groups/lists is not recommended\n   */\n  if (isVModeled) {\n    watch(\n      toRef(props, 'modelValue'),\n      (value) => {\n        if (!eq(clonedValueBeforeVmodel, value)) {\n          node.input(value, false)\n        }\n      },\n      { deep: true }\n    )\n\n    /**\n     * On initialization, if the node’s value was updated (like in a plugin\n     * hook) then we should emit a `modelUpdated` event.\n     */\n    if (node.value !== value) {\n      node.emit('modelUpdated')\n    }\n  }\n\n  /**\n   * When this input shuts down, we need to \"delete\" the node too.\n   */\n  onBeforeUnmount(() => node.destroy())\n\n  return node\n}\n", "import {\n  FormKitOptions,\n  FormKitNode,\n  FormKitRootConfig,\n  getNode,\n  createConfig,\n  setErrors,\n  clearErrors,\n  submitForm,\n  reset,\n} from '@formkit/core'\nimport type { App, Plugin, InjectionKey } from 'vue'\nimport FormKit, { FormKitComponent } from './FormKit'\nimport FormKitSchema from './FormKitSchema'\n\ndeclare module 'vue' {\n  interface ComponentCustomProperties {\n    $formkit: FormKitVuePlugin\n  }\n  interface GlobalComponents {\n    // @ts-ignore\n    FormKit: FormKitComponent\n    FormKitSchema: typeof FormKitSchema\n  }\n}\n/**\n * The global instance of the FormKit plugin.\n *\n * @public\n */\nexport interface FormKitVuePlugin {\n  get: (id: string) => FormKitNode | undefined\n  setLocale: (locale: string) => void\n  setErrors: (\n    formId: string,\n    errors: string[] | Record<string, string | string[]>,\n    inputErrors?: string[] | Record<string, string | string[]>\n  ) => void\n  clearErrors: (formId: string) => void\n  submit: (formId: string) => void\n  reset: (formId: string, resetTo?: unknown) => void\n}\n\n/**\n * The Create a new instance of the FormKit plugin for Vue.\n *\n * @param app - A Vue application\n * @param config - FormKit Vue plugin configuration options\n *\n * @internal\n */\nfunction createPlugin(\n  app: App<any>,\n  options: FormKitOptions & Record<string, any>\n): FormKitVuePlugin {\n  app\n    .component(options.alias || 'FormKit', FormKit as any)\n    .component(options.schemaAlias || 'FormKitSchema', FormKitSchema)\n  return {\n    get: getNode,\n    setLocale: (locale: string) => {\n      if (options.config?.rootConfig) {\n        options.config.rootConfig.locale = locale\n      }\n    },\n    clearErrors,\n    setErrors,\n    submit: submitForm,\n    reset,\n  }\n}\n\n/**\n * The symbol key for accessing the FormKit node options.\n *\n * @public\n */\nexport const optionsSymbol: InjectionKey<FormKitOptions> =\n  Symbol.for('FormKitOptions')\n\n/**\n * The symbol key for accessing FormKit root configuration.\n *\n * @public\n */\nexport const configSymbol: InjectionKey<FormKitRootConfig> =\n  Symbol.for('FormKitConfig')\n\n/**\n * Create the FormKit plugin.\n *\n * @public\n */\nexport const plugin: Plugin = {\n  install(\n    app,\n    _options: FormKitOptions | ((...args: any[]) => FormKitOptions)\n  ): void {\n    /**\n     * Extend the default configuration options.\n     */\n    const options: FormKitOptions = Object.assign(\n      {\n        alias: 'FormKit',\n        schemaAlias: 'FormKitSchema',\n      },\n      typeof _options === 'function' ? _options() : _options\n    )\n    /**\n     * The root configuration options.\n     */\n    const rootConfig = createConfig(options.config || {})\n    /**\n     * We dont want to explicitly provide any \"config\" options, only a root\n     * config option — so here we override the existing config options.\n     */\n    options.config = { rootConfig }\n    /**\n     * Register the global $formkit plugin property.\n     */\n    app.config.globalProperties.$formkit = createPlugin(app, options)\n    /**\n     * Provide the config to the application for injection.\n     */\n    app.provide(optionsSymbol, options)\n    /**\n     * Provide the root config to the application.\n     */\n    app.provide(configSymbol, rootConfig)\n    /**\n     * Register the FormKit component globally.\n     */\n    if (typeof window !== 'undefined') {\n      globalThis.__FORMKIT_CONFIGS__ = (\n        globalThis.__FORMKIT_CONFIGS__ || []\n      ).concat([rootConfig])\n    }\n  },\n}\n", "import {\n  FormKitTypeDefinition,\n  FormKitSchemaNode,\n  FormKitSectionsSchema,\n} from '@formkit/core'\nimport { cloneAny } from '@formkit/utils'\nimport { createSection, FormKitSection, useSchema } from '@formkit/inputs'\nimport { Component, markRaw } from 'vue'\n\nlet totalCreated = 1\n\n/**\n * Determine if the given object is a vue component.\n *\n * @param obj - Object or function\n * @returns\n * @public\n */\nfunction isComponent(obj: any): obj is Component {\n  return (\n    (typeof obj === 'function' && obj.length === 2) ||\n    (typeof obj === 'object' &&\n      !Array.isArray(obj) &&\n      !('$el' in obj) &&\n      !('$cmp' in obj) &&\n      !('if' in obj))\n  )\n}\n\n/**\n * Creates a new input from schema or a Vue component with the \"standard\"\n * FormKit features in place such as labels, help text, validation messages, and\n * class support.\n *\n * @param schemaOrComponent - The actual schema of the input or the component.\n * @param definitionOptions - Any options in the FormKitTypeDefinition you want\n * to define.\n *\n * @returns {@link @formkit/core#FormKitTypeDefinition | FormKitTypeDefinition}\n *\n * @public\n */\nexport function createInput<V = unknown>(\n  schemaOrComponent: FormKitSchemaNode | FormKitSection | Component,\n  definitionOptions: Partial<FormKitTypeDefinition<V>> = {},\n  sectionsSchema: FormKitSectionsSchema = {}\n): FormKitTypeDefinition<V> {\n  const definition: FormKitTypeDefinition<V> = {\n    type: 'input',\n    ...definitionOptions,\n  }\n  let schema: FormKitSection\n  if (isComponent(schemaOrComponent)) {\n    const cmpName = `SchemaComponent${totalCreated++}`\n    schema = createSection('input', () => ({\n      $cmp: cmpName,\n      props: {\n        context: '$node.context',\n      },\n    }))\n    definition.library = { [cmpName]: markRaw(schemaOrComponent) }\n  } else if (typeof schemaOrComponent === 'function') {\n    schema = schemaOrComponent\n  } else {\n    schema = createSection('input', () => cloneAny(schemaOrComponent))\n  }\n\n  // Use the default wrapping schema\n  definition.schema = useSchema(schema || 'Schema undefined', sectionsSchema)\n  if (!definition.schemaMemoKey) {\n    definition.schemaMemoKey = `${Math.random()}`\n  }\n  return definition\n}\n", "import { DefaultConfigOptions } from '../index'\n\nexport function defineFormKitConfig(\n  config: DefaultConfigOptions | (() => DefaultConfigOptions)\n): () => DefaultConfigOptions {\n  return () => (typeof config === 'function' ? config() : config)\n}\n", "import {\n  h,\n  defineComponent,\n  ref,\n  computed,\n  reactive,\n  onMounted,\n  KeepAlive,\n} from 'vue'\nimport { FormKitSchemaDefinition } from '@formkit/core'\nimport { FormKitSchema } from './index'\nimport { FormKitNode } from '@formkit/core'\nimport { getNode } from '@formkit/core'\nimport { FormKitSchemaNode } from 'packages/core/src'\n\nlet inputList: Record<string, string[]> = {}\nconst schemas: Record<string, FormKitSchemaDefinition[]> = {}\n\nconst classes = {\n  container: `\n    formkit-kitchen-sink \n    p-8\n  `,\n  tabs: `\n    formkit-tabs \n    mt-4 \n    mr-[min(350px,25vw)]\n  `,\n  tab: `\n    formkit-kitchen-sink-tab\n    inline-block\n    mb-4\n    -mr-px\n    cursor-pointer\n    px-4\n    py-2\n    border\n    border-neutral-200\n    text-neutral-800\n    data-[active]:bg-neutral-800\n    data-[active]:border-neutral-800\n    data-[active]:text-neutral-50\n    hover:bg-neutral-100\n    hover:text-neutral-900\n    dark:border-neutral-700\n    dark:text-neutral-50\n    dark:data-[active]:bg-neutral-100\n    dark:data-[active]:border-neutral-100\n    dark:data-[active]:text-neutral-800\n    dark:hover:bg-neutral-800\n    dark:hover:text-neutral-50\n  `,\n  filterContainer: `\n    formkit-filter-container\n    grid\n    grid-cols-[repeat(auto-fit,300px)]\n    mr-[min(350px,25vw)]\n    -mt-4\n    mb-8\n    px-4\n    pt-8\n    pb-4\n    border\n    relative\n    -translate-y-px\n    max-w-[1000px]\n    border-neutral-200\n    dark:border-neutral-700\n  `,\n  filterGroup: `\n    formkit-filter-group\n    mr-8\n    mb-8\n    [&_legend]:text-lg\n    [&_ul]:columns-2\n    [&_ul>li:first-child]:[column-span:all]\n    [&_ul>li:first-child]:mt-2\n    [&_ul>li:first-child]:mb-2\n    [&_ul>li:first-child]:pb-2\n    [&_ul>li:first-child]:border-b\n    [&_ul>li:first-child]:border-neutral-200\n    dark:[&_ul>li:first-child]:border-neutral-700\n  `,\n  formContainer: `\n    formkit-form-container\n    w-full\n    bg-white\n    rounded\n    border\n    border-neutral-100\n    shadow-lg\n    max-w-[800px]\n    p-[min(5vw,5rem)]\n    dark:bg-neutral-900\n    dark:border-neutral-800\n    dark:shadow-3xl\n    [&_form>h1]:text-2xl\n    [&_form>h1]:mb-4\n    [&_form>h1]:font-bold\n    [&_form>h1+p]:text-base\n    [&_form>h1+p]:mb-4\n    [&_form>h1+p]:-mt-2\n    [&_form_.double]:flex\n    [&_form_.double>*]:w-1/2\n    [&_form_.double>*:first-child]:mr-2\n    [&_form_.triple]:flex\n    [&_form_.triple>*]:w-1/3\n    [&_form_.triple>*:first-child]:mr-2\n    [&_form_.triple>*:last-child]:ml-2\n  `,\n  inputs: `formkit-inputs`,\n  specimen: `\n    formkit-specimen \n    flex \n    flex-col \n    p-2 \n    max-w-[75vw]\n  `,\n  inputSection: `\n    group/section\n    formkit-input-section \n    mr-[min(325px,25vw)]\n  `,\n  specimenGroup: `\n    formkit-specimen-group\n    grid\n    mb-16\n    grid-cols-[repeat(auto-fit,400px)]\n    group-data-[type=\"transferlist\"]/section:grid-cols-[repeat(auto-fit,650px)]\n    group-data-[type=\"multi-step\"]/section:grid-cols-[repeat(auto-fit,550px)]\n  `,\n  inputType: `\n    formkit-input-type\n    block\n    font-bold\n    text-neutral-900\n    border-b\n    border-neutral-100\n    text-3xl\n    mb-8\n    pb-2\n    capitalize\n    dark:border-neutral-800 \n    dark:text-neutral-50\n  `,\n}\n\n/**\n * Fetches the list of inputs from the remote schema repository\n */\nasync function fetchInputList() {\n  const response = await fetch(\n    'https://raw.githubusercontent.com/formkit/input-schemas/master/index.json'\n  )\n  const json = await response.json()\n  return json\n}\n\n/**\n * Fetches the list of inputs from the remote schema repository\n */\nasync function fetchInputSchema(input: string) {\n  try {\n    const response = await fetch(\n      `https://raw.githubusercontent.com/formkit/input-schemas/master/schemas/${input}.json`\n    )\n    const json = await response.json()\n    return json\n  } catch (error) {\n    console.error(error)\n  }\n}\n\n/**\n * Renders FormKit components fetched from a remote schema repository.\n * This is a kitchen sink component that is used for testing purposes.\n * It shows inputs in various states and configurations.\n *\n * @public\n */\nexport const FormKitKitchenSink = /* #__PURE__ */ defineComponent({\n  name: 'FormKitKitchenSink',\n  props: {\n    schemas: {\n      type: Array,\n      required: false,\n    },\n    pro: {\n      type: Boolean,\n      default: true,\n    },\n    addons: {\n      type: Boolean,\n      default: true,\n    },\n    forms: {\n      type: Boolean,\n      default: true,\n    },\n    navigation: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  async setup(props) {\n    onMounted(() => {\n      const filterNode = getNode('filter-checkboxes')\n      data.filters = computed((): string[] => {\n        if (!filterNode?.context) return []\n        const filters = filterNode.context.value\n        const filterValues: string[] = []\n        Object.keys(filters).forEach((key) => {\n          filterValues.push(...filters[key])\n        })\n        return filterValues\n      }) as unknown as string[]\n    })\n\n    inputList = Object.keys(inputList).length\n      ? inputList\n      : await fetchInputList()\n    const promises = []\n    const activeTab = ref('')\n    const inputCheckboxes = computed(() => {\n      const inputGroups: Record<string, Record<string, string | string[]>> = {\n        core: { label: 'Inputs', name: 'core', inputs: inputList.core },\n      }\n      if (props.pro) {\n        inputGroups.pro = {\n          label: 'Pro Inputs',\n          name: 'pro',\n          inputs: inputList.pro,\n        }\n      }\n      if (props.addons) {\n        inputGroups.addons = {\n          label: 'Add-ons',\n          name: 'addons',\n          inputs: inputList.addons,\n        }\n      }\n      return inputGroups\n    })\n\n    if (!props.schemas) {\n      const coreInputPromises = inputList.core.map(async (schema: string) => {\n        const response = await fetchInputSchema(schema)\n        schemas[schema] = response\n      })\n      promises.push(...coreInputPromises)\n\n      if (props.forms) {\n        const formsPromises = inputList.forms.map(async (schema: string) => {\n          const schemaName = `form/${schema}`\n          const response = await fetchInputSchema(schemaName)\n          schemas[schemaName] = response\n        })\n        promises.push(...formsPromises)\n      }\n\n      if (props.pro) {\n        const proInputPromises = inputList.pro.map(async (schema: string) => {\n          const response = await fetchInputSchema(schema)\n          schemas[schema] = response\n        })\n        promises.push(...proInputPromises)\n      }\n\n      if (props.addons) {\n        const addonPromises = inputList.addons.map(async (schema: string) => {\n          const response = await fetchInputSchema(schema)\n          schemas[schema] = response\n        })\n        promises.push(...addonPromises)\n      }\n    } else {\n      const schemaPromises = props.schemas.map(async (schema: unknown) => {\n        const response = await fetchInputSchema(`${schema}`)\n        schemas[`${schema}`] = response\n      })\n      promises.push(...schemaPromises)\n    }\n\n    // a plugin required for the \"select all\" checkbox functionality\n    const selectAll = (node: FormKitNode) => {\n      let previousValue: string[] = []\n      let skip = false\n\n      if (node.props.type !== 'checkbox') return\n      node.on('created', () => {\n        // if the only checked item is the \"all\" checkbox, check all\n        const currentValue = node.value\n        if (\n          Array.isArray(currentValue) &&\n          currentValue.length === 1 &&\n          currentValue[0] === 'all'\n        ) {\n          node.input(\n            node.props.options.map((option: string | Record<string, any>) => {\n              if (typeof option !== 'string') return option.value\n              return option\n            })\n          )\n        }\n        previousValue = Array.isArray(node.value) ? node.value : []\n      })\n      node.on('commit', ({ payload }) => {\n        if (skip) {\n          skip = false\n          return\n        }\n        if (!Array.isArray(payload)) return\n\n        const previousValueHadAll = previousValue.includes('all')\n        const currentValueHasAll = payload.includes('all')\n\n        // if \"all\" was checked, check all\n        if (!previousValueHadAll && currentValueHasAll) {\n          const computedOptions = node.props.options.map(\n            (option: string | Record<string, any>) => {\n              if (typeof option !== 'string') return option.value\n              return option\n            }\n          )\n          node.input(computedOptions)\n          previousValue = computedOptions\n          return\n        }\n\n        // if \"all\" was unchecked, uncheck all\n        if (previousValueHadAll && !currentValueHasAll) {\n          node.input([])\n          previousValue = []\n          return\n        }\n\n        const valueMinusAll = payload.filter((value: string) => value !== 'all')\n        // uncheck \"all\" if we have less than all items checked\n        if (\n          valueMinusAll.length < node.props.options.length - 1 &&\n          currentValueHasAll\n        ) {\n          node.input(valueMinusAll)\n          previousValue = valueMinusAll\n          skip = true\n          return\n        }\n\n        // re-check \"all\" if we manually check all other items\n        if (\n          valueMinusAll.length === node.props.options.length - 1 &&\n          !currentValueHasAll\n        ) {\n          const computedOptions = node.props.options.map(\n            (option: string | Record<string, any>) => {\n              if (typeof option !== 'string') return option.value\n              return option\n            }\n          )\n          node.input(computedOptions)\n          previousValue = Array.isArray(node.value) ? node.value : []\n          return\n        }\n      })\n    }\n\n    // supporting schema functions for async input states\n    const data = reactive({\n      twClasses: classes,\n      basicOptions: Array.from({ length: 15 }, (_, i) => `Option ${i + 1}`),\n      asyncLoader: async () => {\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        return await new Promise<void>(() => {})\n      },\n      paginatedLoader: async ({\n        page,\n        hasNextPage,\n      }: {\n        page: number\n        hasNextPage: () => void\n      }) => {\n        const base = (page - 1) * 10\n        hasNextPage()\n        return Array.from({ length: 10 }, (_, i) => `Option ${base + i + 1}`)\n      },\n      formSubmitHandler: async (data: any) => {\n        await new Promise((resolve) => setTimeout(resolve, 1000))\n        alert('Form submitted (fake) — check console for data object')\n        console.log('Form data:', data)\n      },\n      includes: (array: any[], value: any) => {\n        if (!Array.isArray(array)) return false\n        return array.includes(value)\n      },\n      checkboxPlugins: [selectAll],\n      filters: [] as string[],\n    })\n\n    await Promise.all(promises)\n\n    const inputKeys = Object.keys(schemas)\n\n    // create friendly labels for use in tabs\n    const formNames = inputKeys.map((key: string) => {\n      if (key.startsWith('form/')) {\n        switch (key) {\n          case 'form/tshirt':\n            return {\n              id: key,\n              name: 'Order Form',\n            }\n          default:\n            const name = key.replace('form/', '')\n            return {\n              id: key,\n              name: name.charAt(0).toUpperCase() + name.slice(1) + ' Form',\n            }\n        }\n      }\n      return {\n        id: key,\n        name: '',\n      }\n    })\n    const filteredFormNames = formNames.filter((form) => form.name !== '')\n\n    const forms = inputKeys.filter((schema: string) => {\n      return schema.startsWith('form/')\n    })\n    const inputs = inputKeys.filter(\n      (schema: string) => !schema.startsWith('form/')\n    )\n\n    const tabs: Record<string, string>[] = []\n    if (inputs.length) {\n      tabs.push({\n        id: 'kitchen-sink',\n        name: 'Kitchen Sink',\n      })\n    }\n    if (forms.length) {\n      tabs.push(...filteredFormNames.sort((a, b) => (a.name > b.name ? 1 : -1)))\n    }\n    if (tabs.length) {\n      activeTab.value = tabs[0].id\n    }\n\n    // collection of all inputs to be rendered in the \"kitchen sink\" tab\n    const kitchenSinkRenders = computed(() => {\n      inputs.sort()\n\n      const schemaDefinitions: FormKitSchemaDefinition = inputs.reduce(\n        (schemaDefinitions, inputName: string) => {\n          const schemaDefinition = schemas[inputName]\n          schemaDefinitions.push({\n            $el: 'div',\n            if: '$includes($filters, \"' + inputName + '\")',\n            attrs: {\n              key: inputName,\n              class: '$twClasses.inputSection',\n              'data-type': inputName,\n            },\n            children: [\n              {\n                $el: 'h2',\n                attrs: {\n                  class: '$twClasses.inputType',\n                },\n                children: inputName,\n              },\n              {\n                $el: 'div',\n                attrs: {\n                  class: '$twClasses.specimenGroup',\n                },\n                children: [\n                  ...((Array.isArray(schemaDefinition)\n                    ? schemaDefinition\n                    : [schemaDefinition]\n                  ).map((specimen) => {\n                    return {\n                      $el: 'div',\n                      attrs: {\n                        class: '$twClasses.specimen',\n                      },\n                      children: [specimen],\n                    }\n                  }) as FormKitSchemaNode[]),\n                ],\n              },\n            ],\n          })\n          return schemaDefinitions\n        },\n        [] as FormKitSchemaNode[]\n      )\n\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            return activeTab.value === 'kitchen-sink'\n              ? h(FormKitSchema, { schema: schemaDefinitions, data: data })\n              : null\n          },\n        }\n      )\n    })\n\n    const formRenders = computed(() => {\n      return filteredFormNames\n        .map((form) => {\n          const schemaDefinition = schemas[form.id]\n          return h(\n            'div',\n            {\n              key: form.id,\n            },\n            activeTab.value === form.id\n              ? [\n                  h(\n                    'div',\n                    {\n                      class: classes.formContainer,\n                    },\n                    [\n                      h(FormKitSchema, {\n                        schema: schemaDefinition[0],\n                        data: data,\n                      }),\n                    ]\n                  ),\n                ]\n              : ''\n          )\n        })\n        .filter((form) => form.children)\n    })\n\n    const tabBar = computed(() => {\n      return h(\n        'div',\n        {\n          key: 'tab-bar',\n          class: classes.tabs,\n        },\n        tabs.map((tab) => {\n          return h(\n            'span',\n            {\n              class: classes.tab,\n              key: tab.id,\n              'data-tab': tab.id,\n              'data-active': activeTab.value === tab.id || undefined,\n              onClick: () => {\n                activeTab.value = tab.id\n              },\n            },\n            tab.name\n          )\n        })\n      )\n    })\n\n    const filterCheckboxes = computed(() => {\n      const createCheckboxSchema = (\n        inputGroup: Record<string, string | string[]>\n      ) => {\n        return {\n          $el: 'div',\n          attrs: {\n            class: '$twClasses.filterGroup',\n          },\n          children: [\n            {\n              $formkit: 'checkbox',\n              name: inputGroup.name,\n              label: inputGroup.label,\n              plugins: '$checkboxPlugins',\n              value: ['all'],\n              options: [\n                {\n                  label: 'All',\n                  value: 'all',\n                },\n                ...(Array.isArray(inputGroup.inputs) ? inputGroup.inputs : []),\n              ],\n            },\n          ],\n        }\n      }\n\n      // render each set of checkboxes\n      const filterSchema = h(FormKitSchema, {\n        key: 'filter-checkboxes',\n        data: data,\n        schema: {\n          $formkit: 'group',\n          id: 'filter-checkboxes',\n          children: [\n            {\n              $el: 'div',\n              attrs: {\n                class: '$twClasses.filterContainer',\n              },\n              children: Object.keys(inputCheckboxes.value).map((key) => {\n                const inputGroup = inputCheckboxes.value[key]\n                return createCheckboxSchema(inputGroup)\n              }),\n            },\n          ],\n        },\n      })\n\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            if (\n              !(\n                tabs.find((tab) => tab.id === 'kitchen-sink') &&\n                activeTab.value === 'kitchen-sink'\n              )\n            ) {\n              return null\n            }\n            return filterSchema\n          },\n        }\n      )\n    })\n\n    return () => {\n      return h(\n        'div',\n        {\n          class: classes.container,\n        },\n        [\n          tabs.length > 1 ? tabBar.value : undefined,\n          filterCheckboxes.value,\n          ...formRenders.value,\n          kitchenSinkRenders.value,\n        ]\n      )\n    }\n  },\n})\n\nexport default FormKitKitchenSink\n", "import {\n  defineComponent,\n  PropType,\n  computed,\n  inject,\n  watch,\n  h,\n  Component,\n} from 'vue'\nimport { createSection } from '@formkit/inputs'\nimport {\n  FormKitNode,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n} from '@formkit/core'\nimport { parentSymbol } from './FormKit'\nimport FormKitSchema from './FormKitSchema'\nimport { undefine } from '@formkit/utils'\n\n/**\n * @internal\n */\nconst messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$fns.length($messages)',\n}))\n\n/**\n * @internal\n */\nconst message = createSection('message', () => ({\n  $el: 'li',\n  for: ['message', '$messages'],\n  attrs: {\n    key: '$message.key',\n    id: `$id + '-' + $message.key`,\n    'data-message-type': '$message.type',\n  },\n}))\n\n/**\n * The actual schema to render for the messages.\n */\nconst definition = messages(message('$message.value'))\n\n/**\n * Renders the messages for a parent node, or any node explicitly passed to it.\n * @public\n */\nexport const FormKitMessages = /* #__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object as PropType<FormKitNode> | undefined,\n      required: false,\n    },\n    sectionsSchema: {\n      type: Object as PropType<\n        Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition>\n      >,\n      default: {},\n    },\n    defaultPosition: {\n      type: [String, Boolean] as PropType<\n        'true' | 'false' | boolean | undefined\n      >,\n      default: false,\n    },\n    library: {\n      type: Object as PropType<Record<string, Component>>,\n      default: () => ({}),\n    },\n  },\n  setup(props, context) {\n    const node = computed<FormKitNode | undefined>(() => {\n      return props.node || inject(parentSymbol, undefined)\n    })\n    watch(\n      node,\n      () => {\n        if (node.value?.context && !undefine(props.defaultPosition)) {\n          node.value.context.defaultMessagePlacement = false\n        }\n      },\n      { immediate: true }\n    )\n\n    const schema = definition(props.sectionsSchema || {})\n    const data = computed(() => {\n      return {\n        messages: node.value?.context?.messages || {},\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {},\n      }\n    })\n    return () =>\n      node.value?.context\n        ? h(\n            FormKitSchema,\n            { schema, data: data.value, library: props.library },\n            { ...context.slots }\n          )\n        : null\n  },\n})\n", "import { defineComponent, SetupContext } from 'vue'\nimport { FormKitOptions, createConfig } from '@formkit/core'\nimport { optionsSymbol, configSymbol } from './plugin'\nimport { provide, inject } from 'vue'\nimport { h } from 'vue'\nimport { Suspense } from 'vue'\nimport { getCurrentInstance } from 'vue'\nimport { ComponentInternalInstance } from 'vue'\nimport { VNode } from 'vue'\n\n/**\n * A composable to provide a given configuration to all children.\n * @param config - A FormKit configuration object or a function\n */\nexport function useConfig(\n  config?: FormKitOptions | ((...args: any[]) => FormKitOptions)\n) {\n  const options = Object.assign(\n    {\n      alias: 'FormKit',\n      schemaAlias: 'FormKitSchema',\n    },\n    typeof config === 'function' ? config() : config\n  )\n  /**\n   * The root configuration options.\n   */\n  const rootConfig = createConfig(options.config || {})\n  /**\n   * We dont want to explicitly provide any \"config\" options, only a root\n   * config option — so here we override the existing config options.\n   */\n  options.config = { rootConfig }\n  /**\n   * Provide the config to children.\n   */\n  provide(optionsSymbol, options)\n  /**\n   * Provide the root config to the children.\n   */\n  provide(configSymbol, rootConfig)\n  /**\n   * Register the FormKit component globally.\n   */\n  if (typeof window !== 'undefined') {\n    globalThis.__FORMKIT_CONFIGS__ = (\n      globalThis.__FORMKIT_CONFIGS__ || []\n    ).concat([rootConfig])\n  }\n}\n\nexport interface FormKitProviderProps {\n  config?: FormKitOptions | ((...args: any[]) => FormKitOptions)\n}\n\nexport interface ConfigLoaderProps {\n  defaultConfig?: boolean\n  configFile?: string\n}\n\n/**\n * The FormKitProvider component provides the FormKit config to the children.\n *\n * @public\n */\nexport const FormKitProvider = /* #__PURE__ */ defineComponent(\n  function FormKitProvider<\n    P extends FormKitProviderProps,\n    S extends { default: FormKitOptions }\n  >(props: P, { slots, attrs }: SetupContext<S>) {\n    const options: FormKitOptions = {}\n    if (props.config) {\n      useConfig(props.config)\n    }\n\n    return () =>\n      slots.default\n        ? slots.default(options).map((vnode) => {\n            return h(vnode, {\n              ...attrs,\n              ...vnode.props,\n            })\n          })\n        : null\n  },\n  { props: ['config'], name: 'FormKitProvider', inheritAttrs: false }\n)\n\n/**\n * The FormKitConfigLoader is an async component (meaning it needs a parent or\n * grandparent Suspense component to render) that loads the FormKit config and\n * provides it to the children.\n *\n * @internal\n */\nconst FormKitConfigLoader = /* #__PURE__ */ defineComponent(\n  async function FormKitConfigLoader(props: ConfigLoaderProps, context) {\n    let config = {}\n    if (props.configFile) {\n      const configFile = await import(\n        /*@__formkit.config.ts__*/ /* @vite-ignore */ /* webpackIgnore: true */ props.configFile\n      )\n      config = 'default' in configFile ? configFile.default : configFile\n    }\n    // Ensure this a factory function for runtimeConfig in nuxt.\n    if (typeof config === 'function') {\n      config = config()\n    }\n    /* @__default-config__ */\n    const useDefaultConfig = props.defaultConfig ?? true\n    if (useDefaultConfig) {\n      const { defaultConfig } = await import('./defaultConfig')\n      config = /* @__PURE__ */ defaultConfig(config)\n    }\n    /* @__default-config__ */\n    return () => h(FormKitProvider, { ...context.attrs, config }, context.slots)\n  },\n  {\n    props: ['defaultConfig', 'configFile'],\n    inheritAttrs: false,\n  }\n)\n\n/**\n * The FormKitLazyProvider component performs 2 HOC functions:\n *\n * 1. It checks if a FormKit config has already been provided, if it has it will\n *   render the children immediately.\n * 2. If a config has not been provided, it will render a Suspense component\n *    which will render the children once the config has been loaded by using\n *    the FormKitConfigLoader component.\n *\n * @public\n */\nexport const FormKitLazyProvider = /* #__PURE__ */ defineComponent(\n  function FormKitLazyProvider(\n    props: ConfigLoaderProps,\n    context: SetupContext<typeof Suspense>\n  ) {\n    const config = inject(optionsSymbol, null)\n    /* pass any attrs through */\n    const passthru = (vnode: VNode) => {\n      return h(vnode, {\n        ...context.attrs,\n        ...vnode.props,\n      })\n    }\n    if (config) {\n      // If there is already a config provided, render the children immediately.\n      return () =>\n        context.slots?.default ? context.slots.default().map(passthru) : null\n    }\n    const instance = getCurrentInstance() as ComponentInternalInstance & {\n      suspense?: boolean\n    }\n    if (instance.suspense) {\n      // If there is a suspense boundary already in place, we can render the\n      // config loader without another suspense boundary.\n      return () =>\n        h(FormKitConfigLoader, props, {\n          default: () =>\n            context.slots?.default\n              ? context.slots.default().map(passthru)\n              : null,\n        })\n    }\n    // If there is no suspense boundary, and no config, we render the suspense\n    // boundary and the config loader.\n    return () =>\n      h(Suspense, null, {\n        ...context.slots,\n        default: () =>\n          h(FormKitConfigLoader, { ...context.attrs, ...props }, context.slots),\n      })\n  },\n  {\n    props: ['defaultConfig', 'configFile'],\n    inheritAttrs: false,\n  }\n)\n", "import { getNode, watchRegistry, stopWatch } from '@formkit/core'\nimport type {\n  FormKitFrameworkContext,\n  FormKitGroupValue,\n  FormKitNode,\n} from '@formkit/core'\nimport { parentSymbol } from '../FormKit'\nimport { ref, inject, onUnmounted } from 'vue'\nimport type { Ref } from 'vue'\n\n/**\n * Uses the FormKit context to access the current FormKit context. This must be\n * used in a component that is a child of the FormKit component.\n * @param effect - An optional effect callback to run when the context is available.\n */\nexport function useFormKitContext<T = FormKitGroupValue>(\n  effect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined>\n/**\n * Allows access to a specific context by address.\n * @param address - An optional address of the context to access.\n * @param effect - An optional effect callback to run when the context is available.\n */\nexport function useFormKitContext<T = FormKitGroupValue>(\n  address?: string,\n  effect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined>\nexport function useFormKitContext<T = FormKitGroupValue>(\n  addressOrEffect?: string | ((context: FormKitFrameworkContext<T>) => void),\n  optionalEffect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined> {\n  const address =\n    typeof addressOrEffect === 'string' ? addressOrEffect : undefined\n  const effect =\n    typeof addressOrEffect === 'function' ? addressOrEffect : optionalEffect\n  const context = ref<FormKitFrameworkContext<T> | undefined>()\n  const parentNode = inject(parentSymbol, null)\n  if (true && !parentNode) {\n    console.warn(\n      'useFormKitContext must be used as a child of a FormKit component.'\n    )\n  }\n  if (parentNode) {\n    if (address) {\n      context.value = parentNode.at(address)?.context\n      const root = parentNode.at('$root')\n      if (root) {\n        const receipt = root.on('child.deep', () => {\n          const targetNode = parentNode.at(address)\n          if (targetNode && targetNode.context !== context.value) {\n            context.value = targetNode.context as FormKitFrameworkContext<T>\n            if (effect) effect(context.value)\n          }\n        })\n        onUnmounted(() => {\n          root.off(receipt)\n        })\n      }\n    } else {\n      context.value = parentNode?.context\n    }\n  }\n  if (context.value && effect) effect(context.value)\n  return context\n}\n\n/**\n * Allows global access to a specific context by id. The target node MUST have\n * an explicitly defined id.\n * @param id - The id of the node to access the context for.\n * @param effect - An effect callback to run when the context is available.\n */\nexport function useFormKitContextById<T = any>(\n  id: string,\n  effect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined> {\n  const context = ref<FormKitFrameworkContext<T> | undefined>()\n  const targetNode = getNode<T>(id)\n  if (targetNode)\n    context.value = targetNode.context as FormKitFrameworkContext<T>\n  if (!targetNode) {\n    const receipt = watchRegistry(id, ({ payload: node }) => {\n      if (node) {\n        context.value = node.context as FormKitFrameworkContext<T>\n        stopWatch(receipt)\n        if (effect) effect(context.value)\n      }\n    })\n  }\n  if (context.value && effect) effect(context.value)\n  return context\n}\n\n/**\n * Fetches a node by id and returns a ref to the node. The node in question\n * must have an explicitly assigned id prop. If the node is not available, the\n * ref will be undefined until the node is available.\n * @param id - The id of the node to access.\n * @param effect - An optional effect callback to run when the node is available.\n * @returns\n */\nexport function useFormKitNodeById<T>(\n  id: string,\n  effect?: (node: FormKitNode<T>) => void\n): Ref<FormKitNode<T> | undefined> {\n  const nodeRef = ref<FormKitNode<T> | undefined>()\n  const targetNode = getNode<T>(id)\n  if (targetNode) nodeRef.value = targetNode\n  if (!targetNode) {\n    const receipt = watchRegistry(id, ({ payload: node }) => {\n      if (node) {\n        nodeRef.value = node\n        stopWatch(receipt)\n        if (effect) effect(node)\n      }\n    })\n  }\n  if (nodeRef.value && effect) effect(nodeRef.value)\n  return nodeRef\n}\n", "import { defineComponent, PropType, computed, inject, h } from 'vue'\nimport { createSection } from '@formkit/inputs'\nimport { token } from '@formkit/utils'\nimport {\n  FormKitNode,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n  FormKitFrameworkContext,\n} from '@formkit/core'\nimport { parentSymbol } from './FormKit'\nimport FormKitSchema from './FormKitSchema'\nimport { ref } from 'vue'\nimport { localize } from '@formkit/inputs'\nimport { nextTick } from 'vue'\n\nconst summary = createSection('summary', () => ({\n  $el: 'div',\n  attrs: {\n    'aria-live': 'polite',\n  },\n}))\n\nconst summaryInner = createSection('summaryInner', () => ({\n  $el: 'div',\n  if: '$summaries.length && $showSummaries',\n}))\n\n/**\n * @internal\n */\nconst messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$summaries.length && $showSummaries',\n}))\n\n/**\n * @internal\n */\nconst message = createSection('message', () => ({\n  $el: 'li',\n  for: ['summary', '$summaries'],\n  attrs: {\n    key: '$summary.key',\n    'data-message-type': '$summary.type',\n  },\n}))\n\nconst summaryHeader = createSection('summaryHeader', () => ({\n  $el: 'h2',\n  attrs: {\n    id: '$id',\n  },\n}))\n\nconst messageLink = createSection('messageLink', () => ({\n  $el: 'a',\n  attrs: {\n    id: '$summary.key',\n    href: '$: \"#\" + $summary.id',\n    onClick: '$jumpLink',\n  },\n}))\n\n/**\n * The actual schema to render for the messages.\n */\nconst definition = summary(\n  summaryInner(\n    summaryHeader('$summaryHeader'),\n    messages(message(messageLink('$summary.message')))\n  )\n)\n\nexport interface FormKitSummaryMessage {\n  message: string\n  id: string\n  key: string\n  type: string\n}\n\n/**\n * Renders the messages for a parent node, or any node explicitly passed to it.\n * @public\n */\nexport const FormKitSummary = /* #__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object as PropType<FormKitNode> | undefined,\n      required: false,\n    },\n    forceShow: {\n      type: Boolean,\n      default: false,\n    },\n    sectionsSchema: {\n      type: Object as PropType<\n        Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition>\n      >,\n      default: {},\n    },\n  },\n  emits: {\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    show: (_summaries: Array<FormKitSummaryMessage>) => true,\n  },\n  setup(props, context) {\n    const id = `summary-${token()}`\n    const node = computed<FormKitNode | undefined>(() => {\n      return props.node || inject(parentSymbol, undefined)\n    })\n\n    if (!node)\n      throw new Error(\n        'FormKitSummary must have a FormKit parent or use the node prop.'\n      )\n\n    const summaryContexts = ref<Array<FormKitFrameworkContext>>([])\n    const showSummaries = ref(false)\n    const summaries = computed((): Array<FormKitSummaryMessage> => {\n      const summarizedMessages: Array<FormKitSummaryMessage> = []\n      summaryContexts.value.forEach((context) => {\n        for (const idx in context.messages) {\n          const message = context.messages[idx]\n          if (typeof message.value !== 'string') continue\n          summarizedMessages.push({\n            message: message.value,\n            id: context.id,\n            key: `${context.id}-${message.key}`,\n            type: message.type,\n          })\n        }\n      })\n      return summarizedMessages\n    })\n\n    const addContexts = () => {\n      summaryContexts.value = []\n      node.value?.walk(\n        (child) => child.context && summaryContexts.value.push(child.context)\n      )\n    }\n\n    node.value?.on('submit-raw', async () => {\n      addContexts()\n      if (summaries.value.length === 0) return\n      context.emit('show', summaries.value)\n      showSummaries.value = true\n      await nextTick()\n      if (typeof window !== 'undefined') {\n        document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n        if (summaries.value[0]) {\n          document.getElementById(summaries.value[0].key)?.focus()\n        }\n      }\n    })\n    node.value?.on('child', addContexts)\n\n    function jumpLink(e: MouseEvent) {\n      if (e.target instanceof HTMLAnchorElement) {\n        e.preventDefault()\n        const id = e.target.getAttribute('href')?.substring(1)\n        if (id) {\n          document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n          document.getElementById(id)?.focus()\n        }\n      }\n    }\n\n    localize('summaryHeader', 'There were errors in your form.')(node.value!)\n\n    const schema = definition(props.sectionsSchema || {})\n\n    const data = computed(() => {\n      return {\n        id,\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {},\n        summaries: summaries.value,\n        showSummaries: props.forceShow || showSummaries.value,\n        summaryHeader: node.value?.context?.ui?.summaryHeader?.value || '',\n        jumpLink,\n      }\n    })\n    return () =>\n      node.value?.context\n        ? h(FormKitSchema, { schema, data: data.value }, { ...context.slots })\n        : null\n  },\n})\n", "import type { FormKitRootConfig } from '@formkit/core'\n/**\n * The official FormKit/Vue integration. This package is responsible for\n * integrating Vue with FormKit core and other first-party packages.\n *\n *\n * @packageDocumentation\n */\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var __FORMKIT_CONFIGS__: FormKitRootConfig[]\n}\n\n/**\n * The useInput composable.\n */\nexport { useInput } from './composables/useInput'\n\n/**\n * Shorthand for creating inputs with standard FormKit features.\n */\nexport { createInput } from './composables/createInput'\n\n/**\n * The defineFormKitConfig composable.\n */\nexport { defineFormKitConfig } from './composables/defineFormKitConfig'\n\n/**\n * The plugin and plugin types.\n */\nexport * from './plugin'\n\n/**\n * The root FormKit component.\n */\nexport {\n  default as FormKit,\n  FormKitComponent,\n  FormKitSetupContext,\n  Slots,\n  parentSymbol,\n  componentSymbol,\n  getCurrentSchemaNode,\n} from './FormKit'\n\n/**\n * The FormKitRoot wrapper component used to provide context to FormKit\n * about whether a FormKit input is booting in a Document or ShadowRoot.\n */\nexport { FormKitRoot, rootSymbol } from './FormKitRoot'\n\n/**\n * The FormKitKitchenSink component.\n */\nexport { FormKitKitchenSink } from './FormKitKitchenSink'\n\n/**\n * The FormKitMessages component.\n * @public\n */\nexport { FormKitMessages } from './FormKitMessages'\n\n/**\n * The FormKitProvider component.\n * @public\n */\nexport {\n  FormKitProvider,\n  FormKitLazyProvider,\n  useConfig,\n} from './FormKitProvider'\n\n/**\n * Exports the useFormKitContext composable.\n */\nexport {\n  useFormKitContext,\n  useFormKitContextById,\n  useFormKitNodeById,\n} from './composables/useContext'\n\n/**\n * The FormKitSummary component.\n * @public\n */\nexport { FormKitSummary, FormKitSummaryMessage } from './FormKitSummary'\n\n/**\n * The FormKitSchema component.\n */\nexport {\n  FormKitSchema,\n  Renderable,\n  RenderableList,\n  RenderableSlot,\n  RenderableSlots,\n  FormKitComponentLibrary,\n  VirtualNode,\n} from './FormKitSchema'\n\n/**\n * The default configuration.\n */\nexport {\n  defaultConfig,\n  DefaultConfigOptions,\n  PluginConfigs,\n} from './defaultConfig'\n\n/**\n * The vue specific FormKit core plugin. This is generally required for all\n * vue based FormKit configurations.\n */\nexport { default as bindings } from './bindings'\n\n/**\n * A vue component for rendering icons from the FormKit icon registry\n */\nexport { FormKitIcon } from './FormKitIcon'\n\n/**\n * The counter reset for sequential identifiers.\n */\nexport { resetCount } from './utilities/resetCount'\n\n/**\n * Export the reset count explicitly\n */\nexport {\n  errorHandler,\n  setErrors,\n  clearErrors,\n  submitForm,\n  reset,\n} from '@formkit/core'\n\n/**\n * Export the changeLocale function explicitly.\n */\nexport { changeLocale } from '@formkit/i18n'\n\n/**\n * SSR support for cleanup operations relating to SSR.\n */\nexport { ssrComplete, onSSRComplete } from './composables/onSSRComplete'\n", "import { h, ref, watch, defineComponent, inject, PropType } from 'vue'\nimport { optionsSymbol } from './plugin'\nimport { parentSymbol } from './FormKit'\nimport { FormKitPlugin } from '@formkit/core'\nimport { FormKitIconLoader, createIconHandler } from '@formkit/themes'\n\n/**\n * Renders an icon using the current IconLoader set at the root FormKit config\n *\n * @public\n */\nexport const FormKitIcon = /* #__PURE__ */ defineComponent({\n  name: 'FormKitIcon',\n  props: {\n    icon: {\n      type: String,\n      default: '',\n    },\n    iconLoader: {\n      type: Function as PropType<FormKitIconLoader>,\n      default: null,\n    },\n    iconLoaderUrl: {\n      type: Function as PropType<(iconName: string) => string>,\n      default: null,\n    },\n  },\n  setup(props) {\n    const icon = ref<undefined | string>(undefined)\n    const config = inject(optionsSymbol, {})\n    const parent = inject(parentSymbol, null)\n    let iconHandler: FormKitIconLoader | undefined = undefined\n\n    function loadIcon() {\n      if (!iconHandler || typeof iconHandler !== 'function') return\n      const iconOrPromise = iconHandler(props.icon)\n      if (iconOrPromise instanceof Promise) {\n        iconOrPromise.then((iconValue) => {\n          icon.value = iconValue\n        })\n      } else {\n        icon.value = iconOrPromise\n      }\n    }\n\n    if (props.iconLoader && typeof props.iconLoader === 'function') {\n      // if we have a locally supplied loader, then use it\n      iconHandler = createIconHandler(props.iconLoader)\n    } else if (parent && parent.props?.iconLoader) {\n      // otherwise try to inherit from a parent\n      iconHandler = createIconHandler(parent.props.iconLoader)\n    } else if (\n      props.iconLoaderUrl &&\n      typeof props.iconLoaderUrl === 'function'\n    ) {\n      iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl)\n    } else {\n      // grab our iconHandler from the global config\n      const iconPlugin = config?.plugins?.find((plugin) => {\n        return (\n          typeof (plugin as FormKitPlugin & { iconHandler: FormKitIconLoader })\n            .iconHandler === 'function'\n        )\n      }) as (FormKitPlugin & { iconHandler: FormKitIconLoader }) | undefined\n      if (iconPlugin) {\n        iconHandler = iconPlugin.iconHandler\n      }\n    }\n\n    watch(\n      () => props.icon,\n      () => {\n        loadIcon()\n      },\n      { immediate: true }\n    )\n\n    return () => {\n      if (props.icon && icon.value) {\n        return h('span', {\n          class: 'formkit-icon',\n          innerHTML: icon.value,\n        })\n      }\n      return null\n    }\n  },\n})\n\nexport default FormKitIcon\n", "/**\n * Reset any counters in the inputs package.\n */\nimport { resetCounts } from '@formkit/inputs'\nimport { resetCount as coreResetCount } from '@formkit/core'\n\nexport function resetCount() {\n  resetCounts()\n  coreResetCount()\n}\n"],
  "mappings": "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",
  "names": ["has", "date_between", "ends_with", "is", "length", "min", "matches", "eq", "empty", "plugin", "options", "option", "extend", "warn", "has", "files", "file", "createMessage", "toggleChecked", "selectInput", "isComponent", "themePlugin", "icon", "error", "warn", "computed", "ref", "watch", "markRaw", "__export", "isRef", "createMessage", "eq", "has", "camel", "undefine", "shallowClone", "reactive", "message", "messages", "classes", "node", "value", "definition", "options", "extend", "h", "isServer", "token", "library", "getValue", "fragment", "slotData", "schema", "instanceKey", "isBrowser", "defineComponent", "stopWatch", "error", "provide", "getCurrentInstance", "onMounted", "getNode", "initialProps", "watchEffect", "option", "form", "inputs", "inject", "createSection", "messages2", "message2", "createConfig", "FormKitConfigLoader", "icon", "resetCount"]
}
