"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addLinting = addLinting;
const eslint_1 = require("@nx/eslint");
const versions_1 = require("@nx/eslint/src/utils/versions");
const path_1 = require("nx/src/utils/path");
const devkit_1 = require("@nx/devkit");
const lint_1 = require("./lint");
const eslint_file_1 = require("@nx/eslint/src/generators/utils/eslint-file");
const flat_config_1 = require("@nx/eslint/src/utils/flat-config");
async function addLinting(host, options, projectType) {
    if (options.linter === 'eslint') {
        const tasks = [];
        const lintTask = await (0, eslint_1.lintProjectGenerator)(host, {
            linter: options.linter,
            project: options.projectName,
            tsConfigPaths: [
                (0, path_1.joinPathFragments)(options.projectRoot, `tsconfig.${projectType}.json`),
            ],
            unitTestRunner: options.unitTestRunner,
            skipFormat: true,
            setParserOptionsProject: options.setParserOptionsProject,
            rootProject: options.rootProject,
            addPlugin: options.addPlugin,
        });
        tasks.push(lintTask);
        if ((0, flat_config_1.useFlatConfig)(host)) {
        }
        else {
            const addExtendsTask = (0, eslint_file_1.addExtendsToLintConfig)(host, options.projectRoot, [
                'plugin:vue/vue3-essential',
                'eslint:recommended',
                '@vue/eslint-config-typescript',
                '@vue/eslint-config-prettier/skip-formatting',
            ].filter(Boolean));
            tasks.push(addExtendsTask);
        }
        editEslintConfigFiles(host, options.projectRoot);
        const devDependencies = {
            ...lint_1.extraEslintDependencies.devDependencies,
        };
        if ((0, eslint_file_1.isEslintConfigSupported)(host, options.projectRoot) &&
            (0, flat_config_1.useFlatConfig)(host)) {
            devDependencies['@typescript-eslint/parser'] = versions_1.typescriptESLintVersion;
        }
        if (!options.skipPackageJson) {
            const installTask = (0, devkit_1.addDependenciesToPackageJson)(host, lint_1.extraEslintDependencies.dependencies, devDependencies);
            tasks.push(installTask);
        }
        return (0, devkit_1.runTasksInSerial)(...tasks);
    }
    else {
        return () => { };
    }
}
function editEslintConfigFiles(tree, projectRoot) {
    const hasVueFiles = (o) => o.files &&
        (Array.isArray(o.files)
            ? o.files.some((f) => f.endsWith('*.vue'))
            : o.files.endsWith('*.vue'));
    const addVueFiles = (o) => {
        if (!o.files) {
            o.files = ['*.vue'];
        }
        else if (Array.isArray(o.files)) {
            o.files.push('*.vue');
        }
        else {
            o.files = [o.files, '*.vue'];
        }
    };
    if ((0, eslint_file_1.isEslintConfigSupported)(tree, projectRoot)) {
        if ((0, flat_config_1.useFlatConfig)(tree)) {
            (0, eslint_file_1.addPredefinedConfigToFlatLintConfig)(tree, projectRoot, 'flat/recommended', 'vue', 'eslint-plugin-vue');
            // This allows .vue files to be parsed
            (0, eslint_file_1.addOverrideToLintConfig)(tree, projectRoot, {
                files: ['**/*.vue'],
                languageOptions: {
                    parserOptions: {
                        parser: '@typescript-eslint/parser',
                    },
                },
            } // languageOptions is not present on eslintrc override, but it is for flat config
            );
            // Add an empty rules object to users know how to add/override rules
            (0, eslint_file_1.addOverrideToLintConfig)(tree, projectRoot, {
                files: ['*.ts', '*.tsx', '*.js', '*.jsx', '*.vue'],
                rules: { 'vue/multi-word-component-names': 'off' },
            });
        }
        else {
            if ((0, eslint_file_1.lintConfigHasOverride)(tree, projectRoot, (o) => o.parserOptions && !hasVueFiles(o), true)) {
                (0, eslint_file_1.updateOverrideInLintConfig)(tree, projectRoot, (o) => !!o.parserOptions, (o) => {
                    addVueFiles(o);
                    return o;
                });
            }
            else {
                (0, eslint_file_1.replaceOverridesInLintConfig)(tree, projectRoot, [
                    {
                        files: ['*.ts', '*.tsx', '*.js', '*.jsx', '*.vue'],
                        rules: { 'vue/multi-word-component-names': 'off' },
                    },
                ]);
            }
        }
    }
    // Edit root config too
    if (!(0, eslint_file_1.isEslintConfigSupported)(tree)) {
        return;
    }
    if ((0, eslint_file_1.lintConfigHasOverride)(tree, '', (o) => o.rules?.['@nx/enforce-module-boundaries'] && !hasVueFiles(o), true)) {
        (0, eslint_file_1.updateOverrideInLintConfig)(tree, '', (o) => !!o.rules?.['@nx/enforce-module-boundaries'], (o) => {
            addVueFiles(o);
            return o;
        });
    }
}
