"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.libraryGenerator = libraryGenerator;
exports.libraryGeneratorInternal = libraryGeneratorInternal;
const devkit_1 = require("@nx/devkit");
const artifact_name_and_directory_utils_1 = require("@nx/devkit/src/generators/artifact-name-and-directory-utils");
const log_show_project_command_1 = require("@nx/devkit/src/utils/log-show-project-command");
const js_1 = require("@nx/js");
const add_release_config_1 = require("@nx/js/src/generators/library/utils/add-release-config");
const sort_fields_1 = require("@nx/js/src/utils/package-json/sort-fields");
const ts_solution_setup_1 = require("@nx/js/src/utils/typescript/ts-solution-setup");
const use_legacy_versioning_1 = require("nx/src/command-line/release/config/use-legacy-versioning");
const path_1 = require("path");
const add_linting_1 = require("../../utils/add-linting");
const create_ts_config_1 = require("../../utils/create-ts-config");
const ensure_dependencies_1 = require("../../utils/ensure-dependencies");
const component_1 = require("../component/component");
const init_1 = require("../init/init");
const add_vite_1 = require("./lib/add-vite");
const create_library_files_1 = require("./lib/create-library-files");
const determine_entry_fields_1 = require("./lib/determine-entry-fields");
const normalize_options_1 = require("./lib/normalize-options");
function libraryGenerator(tree, schema) {
    return libraryGeneratorInternal(tree, {
        addPlugin: false,
        useProjectJson: true,
        ...schema,
    });
}
async function libraryGeneratorInternal(tree, schema) {
    const tasks = [];
    if (schema.publishable === true && !schema.importPath) {
        throw new Error(`For publishable libs you have to provide a proper "--importPath" which needs to be a valid npm package name (e.g. my-awesome-lib or @myorg/my-lib)`);
    }
    const addTsPlugin = (0, ts_solution_setup_1.shouldConfigureTsSolutionSetup)(tree, schema.addPlugin);
    tasks.push(await (0, js_1.initGenerator)(tree, {
        ...schema,
        addTsPlugin,
        skipFormat: true,
    }));
    const options = await (0, normalize_options_1.normalizeOptions)(tree, schema);
    // If we are using the new TS solution
    // We need to update the workspace file (package.json or pnpm-workspaces.yaml) to include the new project
    if (options.isUsingTsSolutionConfig) {
        await (0, ts_solution_setup_1.addProjectToTsSolutionWorkspace)(tree, options.projectRoot);
    }
    let packageJson = {
        name: options.importPath,
        version: '0.0.1',
    };
    if (!options.useProjectJson) {
        packageJson = {
            ...packageJson,
            ...(0, determine_entry_fields_1.determineEntryFields)(options),
            files: options.publishable ? ['dist', '!**/*.tsbuildinfo'] : undefined,
        };
        if (options.projectName !== options.importPath) {
            packageJson.nx = { name: options.projectName };
        }
        if (options.parsedTags?.length) {
            packageJson.nx ??= {};
            packageJson.nx.tags = options.parsedTags;
        }
    }
    else {
        (0, devkit_1.addProjectConfiguration)(tree, options.projectName, {
            root: options.projectRoot,
            sourceRoot: (0, devkit_1.joinPathFragments)(options.projectRoot, 'src'),
            projectType: 'library',
            tags: options.parsedTags,
            targets: {},
        });
    }
    if (!options.useProjectJson || options.isUsingTsSolutionConfig) {
        (0, devkit_1.writeJson)(tree, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), packageJson);
    }
    tasks.push(await (0, init_1.vueInitGenerator)(tree, {
        ...options,
        skipFormat: true,
    }));
    if (!options.skipPackageJson) {
        tasks.push((0, ensure_dependencies_1.ensureDependencies)(tree, options));
    }
    (0, create_ts_config_1.extractTsConfigBase)(tree);
    tasks.push(await (0, add_linting_1.addLinting)(tree, options, 'lib'));
    (0, create_library_files_1.createLibraryFiles)(tree, options);
    tasks.push(await (0, add_vite_1.addVite)(tree, options));
    if (options.component) {
        const relativeCwd = (0, artifact_name_and_directory_utils_1.getRelativeCwd)();
        const path = (0, devkit_1.joinPathFragments)(options.projectRoot, 'src/lib', options.fileName);
        await (0, component_1.default)(tree, {
            path: relativeCwd ? (0, path_1.relative)(relativeCwd, path) : path,
            skipTests: options.unitTestRunner === 'none' ||
                (options.unitTestRunner === 'vitest' && options.inSourceTests == true),
            export: true,
            routing: options.routing,
            js: options.js,
            inSourceTests: options.inSourceTests,
            skipFormat: true,
        });
    }
    if (!options.skipTsConfig && !options.isUsingTsSolutionConfig) {
        (0, js_1.addTsConfigPath)(tree, options.importPath, [
            (0, devkit_1.joinPathFragments)(options.projectRoot, './src', 'index.' + (options.js ? 'js' : 'ts')),
        ]);
    }
    if (options.js)
        (0, devkit_1.toJS)(tree);
    if (options.isUsingTsSolutionConfig) {
        (0, ts_solution_setup_1.updateTsconfigFiles)(tree, options.projectRoot, 'tsconfig.lib.json', {
            jsx: 'preserve',
            jsxImportSource: 'vue',
            module: 'esnext',
            moduleResolution: 'bundler',
            resolveJsonModule: true,
        }, options.linter === 'eslint'
            ? ['eslint.config.js', 'eslint.config.cjs', 'eslint.config.mjs']
            : undefined);
    }
    (0, sort_fields_1.sortPackageJsonFields)(tree, options.projectRoot);
    if (options.publishable) {
        const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.projectName);
        if (options.isUsingTsSolutionConfig) {
            await (0, add_release_config_1.addReleaseConfigForTsSolution)(tree, options.projectName, projectConfig);
        }
        else {
            const nxJson = (0, devkit_1.readJson)(tree, 'nx.json');
            await (0, add_release_config_1.addReleaseConfigForNonTsSolution)((0, use_legacy_versioning_1.shouldUseLegacyVersioning)(nxJson.release), tree, options.projectName, projectConfig);
        }
        (0, devkit_1.updateProjectConfiguration)(tree, options.projectName, projectConfig);
        tasks.push(await (0, add_release_config_1.releaseTasks)(tree));
    }
    if (!options.skipFormat)
        await (0, devkit_1.formatFiles)(tree);
    // Always run install to link packages.
    if (options.isUsingTsSolutionConfig) {
        tasks.push(() => (0, devkit_1.installPackagesTask)(tree, true));
    }
    tasks.push(() => {
        (0, log_show_project_command_1.logShowProjectCommand)(options.name);
    });
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.default = libraryGenerator;
