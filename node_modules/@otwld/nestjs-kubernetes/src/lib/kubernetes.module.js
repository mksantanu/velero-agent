"use strict";
var KubernetesModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.KubernetesModule = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const kubernetes_factory_1 = require("./kubernetes.factory");
const kubernetes_constants_1 = require("./kubernetes.constants");
let KubernetesModule = KubernetesModule_1 = class KubernetesModule {
    static register(options) {
        const serversOptions = !Array.isArray(options)
            ? options.servers
            : options;
        const servers = (serversOptions || []).map((item) => {
            return {
                provide: item.name || kubernetes_constants_1.KUBERNETES_CONNECTION,
                useValue: kubernetes_factory_1.KubernetesFactory.create(item),
            };
        });
        return {
            module: KubernetesModule_1,
            global: !Array.isArray(options) && options.isGlobal,
            providers: servers,
            exports: servers,
        };
    }
    static registerAsync(options) {
        const serversOptions = !Array.isArray(options) ? options.servers : options;
        const providers = serversOptions.reduce((accProviders, item) => accProviders
            .concat(this.createAsyncProviders(item))
            .concat(item.extraProviders || []), []);
        const imports = serversOptions.reduce((accImports, option) => {
            if (!option.imports) {
                return accImports;
            }
            const toInsert = option.imports.filter((item) => !accImports.includes(item));
            return accImports.concat(toInsert);
        }, []);
        return {
            module: KubernetesModule_1,
            global: !Array.isArray(options) && options.isGlobal,
            imports,
            providers: providers,
            exports: providers,
        };
    }
    static createAsyncProviders(options) {
        if (options.useExisting || options.useFactory) {
            return [this.createAsyncOptionsProvider(options)];
        }
        return [
            this.createAsyncOptionsProvider(options),
            {
                provide: options.useClass,
                useClass: options.useClass,
            },
        ];
    }
    static createAsyncOptionsProvider(options) {
        if (options.useFactory) {
            return {
                provide: options.name || kubernetes_constants_1.KUBERNETES_CONNECTION,
                useFactory: this.createFactoryWrapper(options.useFactory),
                inject: options.inject || [],
            };
        }
        return {
            provide: options.name || kubernetes_constants_1.KUBERNETES_CONNECTION,
            useFactory: this.createFactoryWrapper((optionsFactory) => optionsFactory.createKubernetesOptions()),
            inject: [options.useExisting || options.useClass],
        };
    }
    static createFactoryWrapper(useFactory) {
        return async (...args) => {
            const clientOptions = await useFactory(...args);
            return kubernetes_factory_1.KubernetesFactory.create(clientOptions);
        };
    }
};
exports.KubernetesModule = KubernetesModule;
exports.KubernetesModule = KubernetesModule = KubernetesModule_1 = tslib_1.__decorate([
    (0, common_1.Module)({
        controllers: [],
        providers: [],
        exports: [],
    })
], KubernetesModule);
