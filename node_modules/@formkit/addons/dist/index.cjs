'use strict';

var core = require('@formkit/core');
var autoAnimate = require('@formkit/auto-animate');
var inputs = require('@formkit/inputs');
var utils = require('@formkit/utils');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var autoAnimate__default = /*#__PURE__*/_interopDefault(autoAnimate);

// packages/addons/src/plugins/autoAnimatePlugin.ts
var pendingIds = /* @__PURE__ */ new Map();
var optionOverrides = /* @__PURE__ */ new Map();
var autoAnimateOptionsId = 0;
var observer = null;
var observerTimeout = 0;
function createObserver() {
  observeIds();
  observer = new MutationObserver(() => {
    observeIds();
    if (!pendingIds.size && observer) {
      observer.disconnect();
      observer = null;
    }
  });
  observer.observe(document, { childList: true, subtree: true });
}
function observeIds() {
  pendingIds.forEach((options, id) => {
    const outer = document.getElementById(id);
    if (outer) {
      clearTimeout(observerTimeout);
      pendingIds.delete(id);
      observerTimeout = setTimeout(() => {
        const targets = document.querySelectorAll("[data-auto-animate]");
        targets.forEach((target) => {
          let overrideOptions;
          const optionsId = target.getAttribute("data-auto-animate");
          if (optionsId) {
            overrideOptions = optionOverrides.get(optionsId);
          }
          autoAnimate__default.default(target, overrideOptions || options || {});
        });
      }, 250);
    }
  });
}
function createAutoAnimatePlugin(options, animationTargets = {}) {
  return (node) => {
    node.on("created", () => {
      if (typeof node.props.definition?.schema === "function") {
        if (typeof window === void 0)
          return;
        const originalSchema = node.props.definition.schema;
        node.props.definition.schema = (extensions) => {
          const schema = originalSchema(extensions);
          const finalSchema = Array.isArray(schema) ? schema[0] : schema;
          inputs.eachSection(
            finalSchema,
            (section) => {
              if (core.isDOM(section)) {
                let isAnimationTarget = false;
                const sectionName = section?.meta?.section;
                let instanceId = true;
                if (section?.meta?.autoAnimate) {
                  isAnimationTarget = true;
                  if (typeof section.meta.autoAnimate === "object") {
                    const newOptions = Object.assign(
                      {},
                      options,
                      section.meta.autoAnimate
                    );
                    instanceId = `${node.props.id}-${autoAnimateOptionsId++}`;
                    optionOverrides.set(instanceId, newOptions);
                  }
                }
                if (!isAnimationTarget && sectionName && typeof sectionName === "string") {
                  if (animationTargets.global?.includes(sectionName) || animationTargets[node.props.type]?.includes(sectionName)) {
                    isAnimationTarget = true;
                  }
                }
                if (!isAnimationTarget)
                  return;
                if (!section?.attrs) {
                  section.attrs = { "data-auto-animate": instanceId };
                } else {
                  Object.assign(section.attrs, {
                    "data-auto-animate": instanceId
                  });
                }
                if (node.props.id) {
                  pendingIds.set(node.props.id, options);
                }
              }
            }
          );
          return finalSchema;
        };
      }
      if (!observer && typeof window !== "undefined")
        createObserver();
    });
  };
}
var wrapper = inputs.createSection("wrapper", () => ({
  $el: "div",
  attrs: {
    "data-tab-style": "$tabStyle",
    "data-hide-labels": "$hideProgressLabels"
  }
}));
var badge = inputs.createSection("badge", () => ({
  $el: "span",
  attrs: {
    role: "presentation"
  }
}));
var stepActions = inputs.createSection("stepActions", () => ({
  $el: "div"
}));
var stepInner = inputs.createSection("stepInner", "div");
var stepNext = inputs.createSection("stepNext", () => ({
  $el: "div",
  if: "$isLastStep === false || $stepIndex === 0",
  children: [
    {
      $cmp: "FormKit",
      bind: "$nextAttrs",
      props: {
        type: "button",
        label: {
          if: "$nextLabel",
          then: "$nextLabel",
          else: "$ui.next.value"
        },
        "data-next": "$isLastStep === false",
        onClick: "$handlers.next"
      }
    }
  ]
}));
var stepOuter = inputs.createSection("stepOuter", () => ({
  $el: "div",
  attrs: {
    key: "$id",
    "data-type": "step",
    "data-disabled": "$disabled || undefined",
    "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
    "data-errors": "$state.errors || undefined",
    "data-submitted": "$state.submitted || undefined",
    id: "$id",
    role: "tabpanel",
    "aria-labelledby": '$node.parent.props.id + "_tab_" + $stepIndex',
    class: "$classes.step",
    hidden: "$isActiveStep === false || undefined"
  }
}));
var stepPrevious = inputs.createSection("stepPrevious", () => ({
  $el: "div",
  if: "$isFirstStep === false",
  children: [
    {
      $cmp: "FormKit",
      bind: "$previousAttrs",
      props: {
        type: "button",
        label: {
          if: "$previousLabel",
          then: "$previousLabel",
          else: "$ui.prev.value"
        },
        "data-prev": "$isFirstStep === false",
        onClick: "$handlers.previous"
      }
    }
  ]
}));
var steps = inputs.createSection("steps", () => ({
  $el: "div"
}));
var stepIcon = (sectionKey, el) => {
  return inputs.createSection(`${sectionKey}Icon`, () => {
    const rawIconProp = `_raw${sectionKey.charAt(0).toUpperCase()}${sectionKey.slice(1)}Icon`;
    return {
      if: `$step.${sectionKey}Icon && $step.${rawIconProp}`,
      then: {
        $el: `${el ? el : "span"}`,
        attrs: {
          class: `$classes.${sectionKey}Icon + " formkit-icon"`,
          innerHTML: `$step.${rawIconProp}`,
          role: "presentation",
          onClick: `$handlers.iconClick(${sectionKey})`
        }
      },
      else: {
        if: `$${sectionKey}Icon && $${rawIconProp}`,
        then: {
          $el: `${el ? el : "span"}`,
          attrs: {
            class: `$classes.${sectionKey}Icon + " formkit-icon"`,
            innerHTML: `$${rawIconProp}`,
            role: "presentation",
            onClick: `$handlers.iconClick(${sectionKey})`
          }
        }
      }
    };
  })();
};
var tab = inputs.createSection("tab", () => ({
  $el: "button",
  for: ["step", "index", "$fns.getSteps()"],
  attrs: {
    key: "$step.id",
    type: "button",
    onClick: "$step.makeActive",
    "data-active": "$step.isActiveStep",
    "data-valid": "$step.isValid",
    "data-visited": "$step.hasBeenVisited",
    role: "tab",
    id: '$id + "_tab_" + $index',
    "aria-selected": "$step.isActiveStep || false",
    "aria-controls": "$step.id",
    tabindex: {
      if: "$step.isActiveStep",
      then: "0",
      else: "-1"
    }
  }
}));
var tabLabel = inputs.createSection("tabLabel", () => ({
  $el: "span"
}));
var tabs = inputs.createSection("tabs", () => ({
  $el: "div",
  attrs: {
    role: "tablist"
  }
}));
var multiStepOuter = inputs.createSection("multiStepOuter", () => ({
  $el: "div",
  attrs: {
    key: "$id",
    id: "$id",
    class: "$classes.outer",
    "data-prerender": "$fns.preRenderSteps()",
    "data-family": "$family || undefined",
    "data-type": "$type",
    "data-multiple": '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
    "data-disabled": "$disabled || undefined",
    "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
    "data-errors": "$state.errors || undefined",
    "data-submitted": "$state.submitted || undefined"
  }
}));

// packages/addons/src/plugins/multiStep/schema.ts
var multiStep = {
  /**
   * The actual schema of the input, or a function that returns the schema.
   */
  schema: multiStepOuter(
    wrapper(
      tabs(
        tab(
          inputs.$if(
            '$tabStyle === "tab" || ($tabStyle === "progress" && $hideProgressLabels === false)',
            tabLabel("$step.stepName")
          ),
          inputs.$if(
            "($step.totalErrorCount > 0) && $step.showStepErrors",
            badge("$step.totalErrorCount")
          ),
          inputs.$if(
            "$step.isValid && $step.hasBeenVisited",
            badge(stepIcon("validStep"))
          )
        )
      ),
      steps("$slots.default")
    )
  ),
  /**
   * The type of node, can be a list, group, or input.
   */
  type: "group",
  /**
   * The family of inputs this one belongs too. For example "text" and "email"
   * are both part of the "text" family. This is primary used for styling.
   */
  family: "multi-step",
  /**
   * An array of extra props to accept for this input.
   */
  props: [
    "allowIncomplete",
    "hideProgressLabels",
    "tabStyle",
    "beforeStepChange",
    "validStepIcon"
  ],
  /**
   * Additional features that should be added to your input
   */
  features: [inputs.defaultIcon("validStep", "check"), inputs.disablesChildren]
};
var step = {
  /**
   * The actual schema of the input, or a function that returns the schema.
   */
  schema: stepOuter(
    stepInner("$slots.default"),
    stepActions(stepPrevious(), stepNext())
  ),
  /**
   * The type of node, can be a list, group, or input.
   */
  type: "group",
  /**
   * The family of inputs this one belongs too. For example "text" and "email"
   * are both part of the "text" family. This is primary used for styling.
   */
  family: "",
  /**
   * An array of extra props to accept for this input.
   */
  props: [
    "previousLabel",
    "nextLabel",
    "beforeStepChange",
    "previousAttrs",
    "nextAttrs",
    "validStepIcon"
  ],
  /**
   * Additional features that should be added to your input
   */
  features: [inputs.localize("next"), inputs.localize("prev"), inputs.disablesChildren]
};

// packages/addons/src/plugins/multiStep/multiStepPlugin.ts
var isBrowser = typeof window !== "undefined";
var camel2title = (str) => {
  if (!str)
    return str;
  return str.replace(/([A-Z])/g, (match) => ` ${match}`).replace(/^./, (match) => match.toUpperCase()).trim();
};
function orderSteps(node, steps2) {
  if (!isBrowser || !steps2)
    return steps2;
  const orderedSteps = [...steps2];
  orderedSteps.sort((a, b) => {
    const aEl = node.props.__root?.getElementById(a.id);
    const bEl = node.props.__root?.getElementById(b.id);
    if (!aEl || !bEl)
      return 0;
    return aEl.compareDocumentPosition(bEl) === 2 ? 1 : -1;
  });
  orderedSteps.map((step2) => {
    step2.ordered = true;
  });
  return orderedSteps;
}
function setNodePositionProps(steps2) {
  if (!steps2)
    return;
  steps2.forEach((step2, index) => {
    step2.isFirstStep = index === 0;
    step2.isLastStep = index === steps2.length - 1;
    step2.stepIndex = index;
    step2.steps = steps2;
  });
}
function showStepErrors(step2) {
  if (!step2.showStepErrors)
    return;
  return parseInt(step2.blockingCount) + parseInt(step2.errorCount) > 0;
}
async function isTargetStepAllowed(currentStep, targetStep) {
  if (currentStep === targetStep)
    return true;
  const { allowIncomplete } = currentStep.node.parent?.props || {};
  const parentNode = currentStep.node.parent;
  const currentStepIndex = parentNode?.props.steps.indexOf(currentStep);
  const targetStepIndex = parentNode?.props.steps.indexOf(targetStep);
  const currentStepIsValid = triggerStepValidations(currentStep);
  currentStep.showStepErrors = true;
  if (targetStepIndex >= currentStepIndex) {
    if (!currentStepIsValid && !allowIncomplete) {
      return false;
    }
  }
  const delta = targetStepIndex - currentStepIndex;
  for (let i = 0; i < delta; i++) {
    const intermediateStep = parentNode?.props.steps[currentStepIndex + i];
    const stepIsAllowed = allowIncomplete || intermediateStep.state?.valid;
    if (!stepIsAllowed) {
      return false;
    }
  }
  const beforeStepChange = currentStep.node.props.beforeStepChange || currentStep.node.parent?.props.beforeStepChange;
  if (beforeStepChange && typeof beforeStepChange === "function") {
    if (parentNode) {
      parentNode?.store.set(
        /* @__PURE__ */ core.createMessage({
          key: "loading",
          value: true,
          visible: false
        })
      );
      parentNode.props.disabled = true;
      currentStep.disabled = true;
    }
    const result = await beforeStepChange({
      currentStep,
      targetStep,
      delta: targetStepIndex - currentStepIndex
    });
    if (parentNode) {
      parentNode?.store.remove("loading");
      parentNode.props.disabled = false;
      currentStep.disabled = false;
    }
    if (typeof result === "boolean" && !result)
      return false;
  }
  return true;
}
async function setActiveStep(targetStep, e) {
  if (e) {
    e.preventDefault();
  }
  if (targetStep && targetStep.node.name && targetStep.node.parent) {
    const currentStep = targetStep.node.parent.props.steps.find(
      (step2) => step2.node.name === targetStep.node.parent?.props.activeStep
    );
    const stepIsAllowed = await isTargetStepAllowed(currentStep, targetStep);
    if (stepIsAllowed && targetStep.node.parent.context) {
      targetStep.node.parent.props.activeStep = targetStep.node.name;
    }
  }
}
async function incrementStep(delta, currentStep) {
  if (currentStep && currentStep.node.name && currentStep.node.parent) {
    const steps2 = currentStep.node.parent.props.steps;
    const stepIndex = currentStep.stepIndex;
    const targetStep = steps2[stepIndex + delta];
    if (!targetStep)
      return;
    const stepIsAllowed = await isTargetStepAllowed(currentStep, targetStep);
    if (targetStep && stepIsAllowed) {
      currentStep.node.parent.props.activeStep = targetStep.node.name;
    }
  }
}
function triggerStepValidations(step2) {
  step2.node.walk((n) => {
    n.store.set(
      /* @__PURE__ */ core.createMessage({
        key: "submitted",
        value: true,
        visible: false
      })
    );
  });
  return step2.node.context?.state.valid || step2.node.parent?.props.allowIncomplete;
}
function initEvents(node, el) {
  if (!(el instanceof HTMLElement))
    return;
  el.addEventListener("keydown", (event) => {
    if (event.target instanceof HTMLButtonElement) {
      if (event.key === "Tab" && "data-next" in event.target?.attributes && !event.shiftKey) {
        event.preventDefault();
        const activeStepContext = node.children.find(
          (step2) => !core.isPlaceholder(step2) && step2.name === node.props.activeStep
        );
        if (activeStepContext && activeStepContext.context) {
          incrementStep(1, activeStepContext.context);
        }
      }
    }
  });
}
function createSSRStepsFromTabs(tabs2) {
  if (!tabs2 || !tabs2.length)
    return [];
  const tabsToRender = tabs2[0].type == Symbol.for("v-fgt") && tabs2[0].children ? tabs2[0].children : tabs2;
  const placeholderTabs = tabsToRender.map(
    (tab2, index) => {
      return {
        __isPlaceholder: true,
        stepName: tab2.props?.label || camel2title(tab2.props?.name),
        isFirstStep: index === 0,
        isLastStep: index === tabs2.length - 1,
        isActiveStep: index === 0,
        node: {
          name: tab2.props?.name
        }
      };
    }
  );
  return placeholderTabs;
}
function createPreRenderStepsFunction(node) {
  return () => {
    if (!node.context || node.props.steps)
      return;
    let tabs2 = [];
    if (node.context.slots && node.context.slots.default) {
      tabs2 = node.context.slots.default();
    }
    node.props.steps = node.props.steps || createSSRStepsFromTabs(tabs2);
    node.context.stepCount = node.props.steps.length;
  };
}
function createMultiStepPlugin(options) {
  let isFirstStep = true;
  const multiStepPlugin = (node) => {
    if (node.props.type === "multi-step") {
      if (!node.context)
        return;
      isFirstStep = true;
      node.addProps(["steps", "tabs", "activeStep"]);
      node.context.fns.preRenderSteps = createPreRenderStepsFunction(node);
      node.context.fns.getStepCount = () => {
        if (!node.context)
          return;
        return node.context.stepCount;
      };
      node.context.fns.getSteps = () => {
        if (!node.context)
          return;
        return node.context.steps;
      };
      node.props.allowIncomplete = typeof node.props.allowIncomplete === "boolean" ? node.props.allowIncomplete : typeof options?.allowIncomplete === "boolean" ? options?.allowIncomplete : true;
      node.props.hideProgressLabels = typeof node.props.hideProgressLabels === "boolean" ? node.props.hideProgressLabels : options?.hideProgressLabels || false;
      node.props.tabStyle = node.props.tabStyle || options?.tabStyle || "tab";
      node.context.handlers.triggerStepValidations = triggerStepValidations;
      node.context.handlers.showStepErrors = showStepErrors;
      node.on("created", () => {
        if (!node.context)
          return;
        node.extend("next", {
          get: (node2) => () => {
            incrementStep(
              1,
              node2?.props?.steps.find(
                (step2) => step2.isActiveStep
              )
            );
          },
          set: false
        });
        node.extend("previous", {
          get: (node2) => () => {
            incrementStep(
              -1,
              node2?.props?.steps.find(
                (step2) => step2.isActiveStep
              )
            );
          },
          set: false
        });
        node.extend("goTo", {
          get: (node2) => (target) => {
            if (typeof target === "number") {
              const targetStep = node2.props.steps[target];
              setActiveStep(targetStep);
            } else if (typeof target === "string") {
              const targetStep = node2.props.steps.find(
                (step2) => step2.node.name === target
              );
              setActiveStep(targetStep);
            }
          },
          set: false
        });
        utils.whenAvailable(
          `${node.props.id}`,
          (el) => {
            initEvents(node, el);
          },
          node.props.__root
        );
      });
      node.on("child", ({ payload: childNode }) => {
        if (node.props.steps && node.props.steps.length) {
          node.props.steps = node.props.steps.filter(
            (step2) => !step2.__isPlaceholder
          );
        }
        node.props.steps = Array.isArray(node.props.steps) && node.props.steps.length > 0 ? [...node.props.steps, childNode.context] : [childNode.context];
        node.props.steps = orderSteps(node, node.props.steps);
        setNodePositionProps(node.props.steps);
        childNode.props.stepName = childNode.props.label || camel2title(childNode.name);
        childNode.props.errorCount = 0;
        childNode.props.blockingCount = 0;
        childNode.props.isActiveStep = isFirstStep;
        isFirstStep = false;
        node.props.activeStep = node.props.activeStep ? node.props.activeStep : node.props.steps[0] ? node.props.steps[0].node.name : "";
      });
      node.on("prop:activeStep", ({ payload }) => {
        node.children.forEach((child) => {
          if (core.isPlaceholder(child))
            return;
          child.props.isActiveStep = child.name === payload;
          if (isBrowser && child.name === payload) {
            const el = node.props.__root?.querySelector(
              `[aria-controls="${child.props.id}"]`
            );
            if (el instanceof HTMLButtonElement) {
              el.focus();
            }
          }
        });
      });
      node.on("childRemoved", ({ payload: childNode }) => {
        let removedStepIndex = -1;
        childNode.props.ordered = false;
        node.props.steps = node.props.steps.filter(
          (step2, index) => {
            if (step2.node.name !== childNode.name) {
              return true;
            }
            removedStepIndex = index;
            return false;
          }
        );
        setNodePositionProps(node.props.steps);
        if (node.props.activeStep === childNode.name) {
          const targetIndex = removedStepIndex > 0 ? removedStepIndex - 1 : 0;
          node.props.activeStep = node.props.steps[targetIndex] ? node.props.steps[targetIndex].node.name : "";
        }
      });
    } else if (node.props.type === "step" && node.parent?.props.type === "multi-step") {
      let updateTotalErrorCount2 = function(node2) {
        node2.props.totalErrorCount = node2.props.errorCount + node2.props.blockingCount;
      };
      if (!node.context || !node.parent || !node.parent.context)
        return;
      node.addProps([
        "isActiveStep",
        "isFirstStep",
        "isLastStep",
        "stepName",
        "errorCount",
        "blockingCount",
        "totalErrorCount",
        "showStepErrors",
        "isValid",
        "hasBeenVisited",
        "ordered"
      ]);
      const parentNode = node.parent;
      node.on("created", () => {
        if (!node.context || !parentNode.context)
          return;
        utils.whenAvailable(
          `${node.props.id}`,
          () => {
            parentNode.props.steps = orderSteps(node, parentNode.props.steps);
            setNodePositionProps(parentNode.props.steps);
          },
          node.props.__root
        );
      });
      if (node.context && parentNode.context) {
        parentNode.context.handlers.setActiveStep = (stepNode) => setActiveStep.bind(null, stepNode);
        node.context.handlers.incrementStep = (delta) => () => incrementStep(delta, node.context);
        node.context.makeActive = () => {
          setActiveStep(node.context);
        };
        node.context.handlers.next = () => incrementStep(1, node.context);
        node.context.handlers.previous = () => incrementStep(-1, node.context);
      }
      node.on("count:errors", ({ payload: count }) => {
        node.props.errorCount = count;
      });
      node.on("count:blocking", ({ payload: count }) => {
        node.props.blockingCount = count;
      });
      node.on("prop:errorCount", () => updateTotalErrorCount2(node));
      node.on("prop:blockingCount", () => updateTotalErrorCount2(node));
      node.on("prop:totalErrorCount", () => {
        node.props.isValid = node.props.totalErrorCount <= 0;
      });
      node.on("message-added", ({ payload }) => {
        if (payload.key === "submitted") {
          updateTotalErrorCount2(node);
          if (node.context) {
            triggerStepValidations(node.context);
            node.props.showStepErrors = true;
          }
        }
      });
      node.on("prop:isActiveStep", () => {
        if (!node.props.hasBeenVisited && node.props.isActiveStep) {
          node.props.hasBeenVisited = true;
        }
      });
    } else if (node.parent?.props.type === "multi-step") {
      console.warn(
        'Invalid FormKit input location. <FormKit type="multi-step"> should only have <FormKit type="step"> inputs as immediate children. Failure to wrap child inputs in <FormKit type="step"> can lead to undesired behaviors.'
      );
    }
  };
  multiStepPlugin.library = (node) => {
    switch (node.props.type) {
      case "multi-step":
        return node.define(multiStep);
      case "step":
        const isInvalid = !node.parent || node.parent.props.type !== "multi-step";
        if (isInvalid) {
          console.warn(
            'Invalid use of <FormKit type="step">. <FormKit type="step"> must be an immediate child of a <FormKit type="multi-step"> component.'
          );
        }
        return node.define(step);
    }
  };
  return multiStepPlugin;
}
function findParentWithBackgroundColor(element) {
  let backgroundColor = "white";
  while (backgroundColor === "white" && element.parentElement) {
    element = element.parentElement;
    const style = window.getComputedStyle(element);
    const bgColor = style.backgroundColor;
    if (bgColor && bgColor !== "rgba(0, 0, 0, 0)" && bgColor !== "transparent") {
      backgroundColor = bgColor;
    }
    const opacityMatch = backgroundColor.match(/var\(([^)]+)\)/);
    if (opacityMatch) {
      const opacityVar = opacityMatch[1];
      const opacity = getComputedStyle(document.documentElement).getPropertyValue(opacityVar).trim() || "1";
      backgroundColor = `rgba(${bgColor}, ${opacity})`;
    }
  }
  return backgroundColor;
}
function setBackgroundColor(node, nodeRoot, timeout) {
  setTimeout(() => {
    node.props._labelBackgroundColor = findParentWithBackgroundColor(nodeRoot);
  }, timeout);
}
function createFloatingLabelsPlugin(FloatingLabelsOptions) {
  const floatingLabelsPlugin = (node) => {
    let nodeEl = null;
    node.addProps({
      floatingLabel: {
        boolean: true,
        default: !!FloatingLabelsOptions?.useAsDefault
      },
      _labelBackgroundColor: {},
      _labelOffset: {},
      _offsetCalculated: {}
    });
    const useFloatingLabels = node.props.floatingLabel;
    if (useFloatingLabels && node.context) {
      let calculateLabelOffset2 = function(node2, nodeEl2) {
        const labelEl = nodeEl2.parentNode?.querySelector(".formkit-label");
        const left = nodeEl2.offsetLeft;
        const style = window.getComputedStyle(nodeEl2);
        const paddingLeft = parseInt(style.paddingLeft, 10);
        const offset = left + paddingLeft;
        if (labelEl && offset) {
          node2.props._labelOffset = `calc(${offset}px - 0.25em)`;
        }
      };
      node.on("created", () => {
        if (!node.props || !node.props.definition || !node.context)
          return;
        node.context.handlers.updateLabelBackgroundColor = () => {
          if (!node.context || !nodeEl)
            return;
          setBackgroundColor(node, nodeEl, 0);
        };
        const inputDefinition = utils.clone(node.props.definition);
        if (["text", "dropdown"].includes(node.props.family) || ["datepicker", "textarea"].includes(node.props.type)) {
          const originalSchema = inputDefinition.schema;
          if (typeof originalSchema !== "function")
            return;
          const higherOrderSchema = (extensions) => {
            extensions.outer = {
              attrs: {
                "data-floating-label": "true"
              }
            };
            extensions.label = {
              attrs: {
                style: {
                  if: "$_offsetCalculated",
                  then: '$: "background-color: " + $_labelBackgroundColor + "; left: " + $_labelOffset + ";"',
                  else: '$: "transition: none; background-color: " + $_labelBackgroundColor + "; left: " + $_labelOffset + ";"'
                }
              }
            };
            const inputSchema = originalSchema(extensions);
            const finalSchema = Array.isArray(inputSchema) ? inputSchema[0] : inputSchema;
            const [labelParentChildren, labelSection] = inputs.findSection(
              finalSchema,
              "label"
            );
            const targetSection = node.props.type === "dropdown" ? "selector" : "input";
            const [inputParentChildren] = inputs.findSection(
              finalSchema,
              targetSection
            );
            if (Array.isArray(labelParentChildren) && labelSection && Array.isArray(inputParentChildren)) {
              labelParentChildren.splice(
                labelParentChildren.indexOf(labelSection),
                1
              );
              inputParentChildren.push(labelSection);
            }
            return inputSchema;
          };
          inputDefinition.schema = higherOrderSchema;
          if (inputDefinition.schemaMemoKey) {
            inputDefinition.schemaMemoKey += "-floating-label";
          }
          node.props.definition = inputDefinition;
        }
      });
      node.on("mounted", () => {
        if (!node.context)
          return;
        const observer2 = new MutationObserver(() => {
          if (!nodeEl)
            return;
          calculateLabelOffset2(node, nodeEl);
          setTimeout(() => {
            node.props._offsetCalculated = true;
          }, 100);
        });
        utils.whenAvailable(node.context.id, () => {
          if (!node.context)
            return;
          nodeEl = document.getElementById(node.context?.id);
          if (!nodeEl)
            return;
          setBackgroundColor(node, nodeEl, 100);
          observer2.observe(nodeEl.parentNode, {
            childList: true,
            subtree: true,
            attributes: true
          });
        });
      });
    }
  };
  return floatingLabelsPlugin;
}
function createLocalStoragePlugin(localStorageOptions) {
  const localStoragePlugin = (node) => {
    if (node.type !== "group")
      return;
    if (typeof window === "undefined")
      return;
    let cachedLocalStorageData = "";
    const shouldUseLocalStorage = (controlNode) => {
      let controlFieldValue = true;
      if (controlNode) {
        controlFieldValue = controlNode.value === true;
      }
      return utils.undefine(node.props.useLocalStorage) && controlFieldValue;
    };
    node.on("created", async () => {
      await node.settled;
      node.addProps(["useLocalStorage"]);
      node.extend("restoreCache", {
        get: (node2) => async () => {
          if (!cachedLocalStorageData)
            return;
          await node2.settled;
          loadValue(cachedLocalStorageData);
        },
        set: false
      });
      const controlField = localStorageOptions?.control ?? void 0;
      let controlNode;
      if (typeof controlField === "string") {
        const controlNode2 = node.at(controlField);
        if (controlNode2) {
          controlNode2.on("commit", () => {
            useLocalStorage = shouldUseLocalStorage(controlNode2);
            if (!useLocalStorage) {
              localStorage.removeItem(storageKey);
            }
          });
        }
      }
      let useLocalStorage = shouldUseLocalStorage(controlNode);
      let saveTimeout = 0;
      const debounce = typeof localStorageOptions?.debounce === "number" ? localStorageOptions.debounce : 200;
      const prefix = localStorageOptions?.prefix ?? "formkit";
      const maxAge = localStorageOptions?.maxAge ?? 36e5;
      const key = localStorageOptions?.key ? `-${localStorageOptions.key}` : "";
      const storageKey = `${prefix}${key}-${node.name}`;
      const clearOnSubmit = localStorageOptions?.clearOnSubmit ?? true;
      const loadValue = async (forceValue) => {
        const value = forceValue || localStorage.getItem(storageKey);
        if (!value)
          return;
        const loadValue2 = JSON.parse(value);
        if (typeof localStorageOptions?.beforeLoad === "function") {
          node.props.disabled = true;
          try {
            loadValue2.data = await localStorageOptions.beforeLoad(
              loadValue2.data
            );
          } catch (error) {
            console.error(error);
          }
          node.props.disabled = false;
        }
        if (!loadValue2 || typeof loadValue2.data !== "object")
          return;
        if (loadValue2.maxAge > Date.now()) {
          node.input(loadValue2.data, false);
        } else {
          localStorage.removeItem(storageKey);
        }
      };
      const saveValue = async (payload) => {
        let savePayload = payload;
        if (typeof localStorageOptions?.beforeSave === "function") {
          try {
            savePayload = await localStorageOptions.beforeSave(payload);
          } catch (error) {
            console.error(error);
          }
        }
        if (!savePayload)
          return;
        localStorage.setItem(
          storageKey,
          JSON.stringify({
            maxAge: Date.now() + maxAge,
            data: savePayload
          })
        );
      };
      node.on("commit", ({ payload }) => {
        if (!useLocalStorage)
          return;
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(async () => {
          saveValue(payload);
        }, debounce);
      });
      node.on("prop:useLocalStorage", () => {
        useLocalStorage = shouldUseLocalStorage(controlNode);
        if (!useLocalStorage) {
          localStorage.removeItem(storageKey);
        }
      });
      if (clearOnSubmit) {
        node.hook.submit((payload, next) => {
          cachedLocalStorageData = localStorage.getItem(storageKey);
          localStorage.removeItem(storageKey);
          return next(payload);
        });
      }
      await loadValue();
    });
  };
  return localStoragePlugin;
}
function createAutoHeightTextareaPlugin() {
  const autoHeightTextareaPlugin = (node) => {
    if (node.props.type !== "textarea")
      return;
    node.addProps(["autoHeight", "maxAutoHeight"]);
    node.on("mounted", () => {
      const autoHeight = utils.undefine(node.props.autoHeight);
      const maxAutoHeight = Number.isFinite(node.props.maxAutoHeight) ? parseInt(node.props.maxAutoHeight) : void 0;
      if (!autoHeight || !node.context)
        return;
      let inputElement = null;
      utils.whenAvailable(
        node.context.id,
        () => {
          inputElement = node.props.__root?.getElementById(
            node?.context?.id ? node.context.id : ""
          );
          if (!(inputElement instanceof HTMLTextAreaElement))
            return;
          if (!document.getElementById("formkit-auto-height-textarea-style")) {
            const scrollbarStyle = document.createElement("style");
            scrollbarStyle.setAttribute(
              "id",
              "formkit-auto-height-textarea-style"
            );
            scrollbarStyle.textContent = `.formkit-auto-height-textarea { scrollbar-width: none; } .formkit-auto-height-textarea::-webkit-scrollbar { display: none; }`;
            document.body.appendChild(scrollbarStyle);
          }
          const hiddenTextarea = inputElement.cloneNode(
            false
          );
          hiddenTextarea.classList.add("formkit-auto-height-textarea");
          if (!maxAutoHeight) {
            inputElement.classList.add("formkit-auto-height-textarea");
          }
          hiddenTextarea.setAttribute(
            "style",
            "height: 0; min-height: 0; pointer-events: none; opacity: 0;  left: -9999px; padding-top: 0; padding-bottom: 0; position: absolute; display: block; top: 0; z-index: -1; scrollbar-width: none;"
          );
          hiddenTextarea.setAttribute("aria-hidden", "true");
          hiddenTextarea.setAttribute("tabindex", "-1");
          hiddenTextarea.removeAttribute("name");
          hiddenTextarea.removeAttribute("id");
          hiddenTextarea.removeAttribute("aria-describedby");
          const isBorderBox = getComputedStyle(inputElement).boxSizing === "border-box";
          const paddingY = parseInt(getComputedStyle(inputElement).paddingTop) + parseInt(getComputedStyle(inputElement).paddingBottom);
          const paddingX = parseInt(getComputedStyle(inputElement).paddingTop) + parseInt(getComputedStyle(inputElement).paddingBottom);
          let lastValue = node._value;
          inputElement.after(hiddenTextarea);
          calculateHeight({ payload: node._value });
          node.on("input", calculateHeight);
          async function calculateHeight({ payload }) {
            lastValue = payload;
            if (!inputElement)
              return;
            await new Promise((r) => setTimeout(r, 10));
            if (lastValue !== payload)
              return;
            hiddenTextarea.value = payload;
            const width = isBorderBox ? inputElement.offsetWidth : inputElement.offsetWidth - paddingX;
            hiddenTextarea.style.width = `${width}px`;
            const scrollHeight = hiddenTextarea.scrollHeight;
            const height = isBorderBox ? scrollHeight + paddingY : scrollHeight;
            const h = maxAutoHeight ? Math.min(height, maxAutoHeight) : height;
            if (!inputElement.style.height) {
              inputElement.style.height = `0px`;
            }
            inputElement.style.minHeight = `${h}px`;
          }
        },
        node.props.__root
      );
    });
  };
  return autoHeightTextareaPlugin;
}

exports.createAutoAnimatePlugin = createAutoAnimatePlugin;
exports.createAutoHeightTextareaPlugin = createAutoHeightTextareaPlugin;
exports.createFloatingLabelsPlugin = createFloatingLabelsPlugin;
exports.createLocalStoragePlugin = createLocalStoragePlugin;
exports.createMultiStepPlugin = createMultiStepPlugin;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.cjs.map