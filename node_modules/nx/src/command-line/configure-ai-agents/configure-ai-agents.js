"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureAiAgentsHandler = configureAiAgentsHandler;
exports.configureAiAgentsHandlerImpl = configureAiAgentsHandlerImpl;
const enquirer_1 = require("enquirer");
const output_1 = require("../../utils/output");
const provenance_1 = require("../../utils/provenance");
const chalk = require("chalk");
const utils_1 = require("../../ai/utils");
const devkit_internals_1 = require("../../devkit-internals");
const workspace_root_1 = require("../../utils/workspace-root");
const ora = require("ora");
const path_1 = require("path");
async function configureAiAgentsHandler(args, inner = false) {
    // Use environment variable to force local execution
    if (process.env.NX_AI_FILES_USE_LOCAL === 'true' || inner) {
        return await configureAiAgentsHandlerImpl(args);
    }
    let cleanup;
    try {
        await (0, provenance_1.ensurePackageHasProvenance)('nx', 'latest');
        const packageInstallResults = (0, devkit_internals_1.installPackageToTmp)('nx', 'latest');
        cleanup = packageInstallResults.cleanup;
        let modulePath = require.resolve('nx/src/command-line/configure-ai-agents/configure-ai-agents.js', { paths: [packageInstallResults.tempDir] });
        const module = await Promise.resolve(`${modulePath}`).then(s => require(s));
        const configureAiAgentsResult = await module.configureAiAgentsHandler(args, true);
        cleanup();
        return configureAiAgentsResult;
    }
    catch (error) {
        if (cleanup) {
            cleanup();
        }
        // Fall back to local implementation
        return configureAiAgentsHandlerImpl(args);
    }
}
async function configureAiAgentsHandlerImpl(options) {
    const normalizedOptions = normalizeOptions(options);
    const { nonConfiguredAgents, partiallyConfiguredAgents, fullyConfiguredAgents, disabledAgents, agentConfigurations, } = await (0, utils_1.getAgentConfigurations)(normalizedOptions.agents, workspace_root_1.workspaceRoot);
    if (disabledAgents.length > 0) {
        const commandNames = disabledAgents.map((a) => {
            if (a === 'cursor')
                return '"cursor"';
            if (a === 'copilot')
                return '"code"/"code-insiders"';
            return a;
        });
        const title = commandNames.length === 1
            ? `${commandNames[0]} command not available.`
            : `CLI commands ${commandNames
                .map((c) => `${c}`)
                .join('/')} not available.`;
        output_1.output.log({
            title,
            bodyLines: [
                chalk.dim('To manually configure the Nx MCP in your editor, install Nx Console (https://nx.dev/getting-started/editor-setup)'),
            ],
        });
    }
    if (normalizedOptions.agents.filter((a) => !disabledAgents.includes(a))
        .length === 0) {
        output_1.output.error({
            title: 'Please select at least one AI agent to configure.',
        });
        process.exit(1);
    }
    if (options.check) {
        if (fullyConfiguredAgents.length === 0) {
            output_1.output.log({
                title: 'No AI agents are configured',
                bodyLines: [
                    'You can configure AI agents by running `nx configure-ai-agents`.',
                ],
            });
            process.exit(0);
        }
        const outOfDateAgents = fullyConfiguredAgents.filter((a) => agentConfigurations.get(a)?.outdated);
        if (outOfDateAgents.length === 0) {
            output_1.output.success({
                title: 'All configured AI agents are up to date',
                bodyLines: fullyConfiguredAgents.map((a) => `- ${utils_1.agentDisplayMap[a]}`),
            });
            process.exit(0);
        }
        else {
            output_1.output.log({
                title: 'The following AI agents are out of date:',
                bodyLines: [
                    ...outOfDateAgents.map((a) => {
                        const rulesPath = agentConfigurations.get(a).rulesPath;
                        const displayPath = rulesPath.startsWith(workspace_root_1.workspaceRoot)
                            ? (0, path_1.relative)(workspace_root_1.workspaceRoot, rulesPath)
                            : rulesPath;
                        return `- ${utils_1.agentDisplayMap[a]} (${displayPath})`;
                    }),
                    '',
                    'You can update them by running `nx configure-ai-agents`.',
                ],
            });
            process.exit(1);
        }
    }
    // first, prompt for partially configured agents and out of date agents
    const agentsToUpdate = [];
    partiallyConfiguredAgents.forEach((a) => {
        agentsToUpdate.push(getAgentChoiceForPrompt(a, true, false));
    });
    for (const a of fullyConfiguredAgents) {
        if (agentConfigurations.get(a).outdated) {
            agentsToUpdate.push(getAgentChoiceForPrompt(a, false, true));
        }
    }
    let updateResult = [];
    let updateSucceeded = true;
    if (agentsToUpdate.length > 0) {
        if (options.interactive !== false) {
            try {
                updateResult = (await (0, enquirer_1.prompt)({
                    type: 'multiselect',
                    name: 'agents',
                    message: 'The following agents are not configured completely or are out of date. Which would you like to update?',
                    choices: agentsToUpdate,
                    initial: agentsToUpdate.map((_, i) => i),
                    required: true,
                })).agents;
            }
            catch {
                process.exit(1);
            }
        }
        else {
            // in non-interactive mode, update all
            updateResult = agentsToUpdate.map((a) => a.name);
        }
        if (updateResult?.length > 0) {
            const updateSpinner = ora(`Updating agent configurations...`).start();
            try {
                await (0, utils_1.configureAgents)(updateResult, workspace_root_1.workspaceRoot, false);
                updateSpinner.succeed('Agent configurations updated.');
            }
            catch {
                updateSpinner.fail('Failed to update agent configurations.');
                updateSucceeded = false;
            }
        }
    }
    // then prompt for non-configured agents
    if (nonConfiguredAgents.length === 0) {
        const usingAllAgents = normalizedOptions.agents.length === utils_1.supportedAgents.length;
        const configuredOrUpdatedAgents = [
            ...new Set([
                ...fullyConfiguredAgents,
                ...(updateSucceeded ? updateResult : []),
            ]),
        ];
        output_1.output.success({
            title: `No new agents to configure. All ${!usingAllAgents ? 'selected' : 'supported'} AI agents are already configured:`,
            bodyLines: configuredOrUpdatedAgents.map((agent) => `- ${utils_1.agentDisplayMap[agent]}`),
        });
        process.exit(0);
    }
    let configurationResult;
    if (options.interactive !== false) {
        try {
            configurationResult = (await (0, enquirer_1.prompt)({
                type: 'multiselect',
                name: 'agents',
                message: 'Which AI agents would you like to configure? (space to select, enter to confirm)',
                choices: nonConfiguredAgents.map((a) => getAgentChoiceForPrompt(a, false, false)),
                required: true,
            })).agents;
        }
        catch {
            process.exit(1);
        }
    }
    else {
        // in non-interactive mode, configure all
        configurationResult = nonConfiguredAgents;
    }
    if (configurationResult?.length === 0) {
        output_1.output.log({
            title: 'No agents selected',
        });
        process.exit(0);
    }
    try {
        await (0, utils_1.configureAgents)(configurationResult, workspace_root_1.workspaceRoot, false);
        const configuredOrUpdatedAgents = [
            ...new Set([
                ...fullyConfiguredAgents,
                ...(updateSucceeded ? updateResult : []),
                ...configurationResult,
            ]),
        ];
        output_1.output.success({
            title: 'AI agents set up successfully. Configured agents:',
            bodyLines: configuredOrUpdatedAgents.map((agent) => `- ${utils_1.agentDisplayMap[agent]}`),
        });
        return;
    }
    catch (e) {
        output_1.output.error({
            title: 'Failed to set up AI agents',
            bodyLines: [e.message],
        });
        process.exit(1);
    }
}
function getAgentChoiceForPrompt(agent, partiallyConfigured, outdated) {
    let message = utils_1.agentDisplayMap[agent];
    if (partiallyConfigured) {
        message += ' (partially configured)';
    }
    else if (outdated) {
        message += ' (out of date)';
    }
    return {
        name: agent,
        message,
    };
}
function normalizeOptions(options) {
    const agents = (options.agents ?? utils_1.supportedAgents).filter((a) => utils_1.supportedAgents.includes(a));
    return {
        ...options,
        agents,
        check: options.check ?? false,
    };
}
